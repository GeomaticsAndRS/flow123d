/* Parallel Hierarchical Grid -- an adaptive finite element library.
 *
 * Copyright (C) 2005-2010 State Key Laboratory of Scientific and
 * Engineering Computing, Chinese Academy of Sciences. */

/* This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA  02110-1301  USA */

/* $Id: quad.c,v 1.183 2011/06/08 06:31:34 zlb Exp $ */

/* Numerical Quadrature */

/*
 * The parts of this file which are unnecessary for Flow123d have been commented out.
 */

#include "quad.h"
//#include <math.h>
//#include <stdlib.h>
//#include <string.h>

#ifdef Length
# undef Length
#endif
#define Length(wts)	(sizeof(wts) / (sizeof(wts[0])))

//typedef QUAD *(*QGEN_FUNC) (int dim, int order);

//void
//phgQuadFree(QUAD **quad)
//{
//    if ((*quad) == NULL)
//	return;
//    phgFree((*quad)->name);
//    phgFree((*quad)->points);
//    phgFree((*quad)->weights);
//    phgFree((*quad));
//
//    *quad = NULL;
//}
//
//static void
//init_table(int n0, QUAD **table0, int *n, QUAD ***table)
//{
//#if USE_OMP
//#pragma omp critical (init_table)
//#endif	/* USE_OMP */
//    if (*table == NULL) {
//	void *p = phgAlloc(n0 * sizeof(*table0));
//	memcpy(p, table0, n0 * sizeof(*table0));
//	*n = n0;
//	*table = p;
//    }
//}
//
//#define nquad0	(sizeof(table0) / sizeof(*table0))
//#define GetQuadrature(qgen_func) {					\
//    static int nquad;							\
//    static QUAD **table = NULL;						\
//    static BOOLEAN warned = FALSE;					\
//									\
//    if (order < 0) {							\
//	/* free dynamically generated quadrature rules */		\
//	CheckThread							\
//	if (table != NULL) {						\
//	    int i, j;							\
//	    for (i = nquad0; i < nquad; i++) {				\
//		for (j = i + 1; j < nquad && table[j] == table[i]; j++)	\
//		    table[j] = NULL;					\
//		phgQuadFree(&table[i]);					\
//	    }								\
//	    phgFree(table);						\
//	    table = NULL;						\
//	}								\
//	return NULL;							\
//    }									\
//    if (table == NULL) {						\
//	/* initialization */						\
//	init_table(nquad0, table0, &nquad, &table);			\
//    }									\
//    if (order >= nquad) {						\
//	if (/*qgen_func == NULL*/FALSE) {				\
//	    if (!warned && phgRank == 0) {				\
//		phgWarning("%dD quad rule of order %d unavailable.\n",	\
//				table[0]->dim, order);			\
//		warned = TRUE;						\
//	    }								\
//	    order = nquad - 1;						\
//	}								\
//	else {								\
//	    if (qgen_func == phgQuadTensorProductRule)			\
//		order = (order / 2) * 2	+ 1;				\
//	    CheckThread							\
//	    table = phgRealloc_(table, (order + 1) * sizeof(*table),	\
//					nquad * sizeof(*table));	\
//	    memset(table + nquad, 0, (order - nquad + 1) * sizeof(*table)); \
//	    nquad = order + 1;						\
//	}								\
//    }									\
//    if (table[order] == NULL) {						\
//	if (FALSE && table[0]->dim > 1 && phgRank == 0) {		\
//	    phgWarning("using %dD-%d tensor product quadrature rule.\n",\
//			table[0]->dim, order);				\
//	}								\
//	CheckThread						\
//	table[order] = (qgen_func)(table[0]->dim, order);		\
//	if (order > nquad0 && qgen_func == phgQuadTensorProductRule)	\
//	    table[order - 1] = table[order];				\
//    }									\
//    return table[order];						\
//}
//
//QUAD *
//phgQuadGetQuad1D(int order)
//{
//    /* Table of static 1D quadrature rules */
//    static QUAD *table0[] = { QUAD_1D_P1,
//	QUAD_1D_P1,	QUAD_1D_P2,	QUAD_1D_P3,
//	QUAD_1D_P4,	QUAD_1D_P5,	QUAD_1D_P6,
//	QUAD_1D_P7,	QUAD_1D_P8,	QUAD_1D_P9,
//	QUAD_1D_P10,	QUAD_1D_P11,	QUAD_1D_P12,
//	QUAD_1D_P13,	QUAD_1D_P14,	QUAD_1D_P15,
//	QUAD_1D_P16,	QUAD_1D_P17,	QUAD_1D_P18,
//	QUAD_1D_P19,	QUAD_1D_P20,	QUAD_1D_P21
//    };
//    GetQuadrature(phgQuadTensorProductRule)
//}
//
//QUAD *
//phgQuadGetQuad2D(int order)
//{
//    /* Table of static 2D quadrature rules */
//    static QUAD *table0[] = { QUAD_2D_P1,
//	QUAD_2D_P1,	QUAD_2D_P2,	QUAD_2D_P3,	QUAD_2D_P4,
//	QUAD_2D_P5,	QUAD_2D_P6,	QUAD_2D_P7,	QUAD_2D_P8,
//	QUAD_2D_P9,	QUAD_2D_P10,	QUAD_2D_P11,	QUAD_2D_P12,
//	QUAD_2D_P13,	QUAD_2D_P14,	QUAD_2D_P15,	QUAD_2D_P16,
//	QUAD_2D_P17,	QUAD_2D_P18,	QUAD_2D_P19,	QUAD_2D_P20,
//	QUAD_2D_P21
//    };
//    GetQuadrature(phgQuadTensorProductRule)
//}
//
//QUAD *
//phgQuadGetQuad3D(int order)
//{
//    /* Table of static 3D quadrature (cubature) rules */
//    static QUAD *table0[] = { QUAD_3D_P1,
//	QUAD_3D_P1,	QUAD_3D_P2,	QUAD_3D_P3,	QUAD_3D_P4,
//	QUAD_3D_P5,	QUAD_3D_P6,	QUAD_3D_P7,	QUAD_3D_P8,
//	QUAD_3D_P9,	QUAD_3D_P10,	QUAD_3D_P11,	QUAD_3D_P12,
//	QUAD_3D_P13,	QUAD_3D_P14
//    };
//    GetQuadrature(phgQuadTensorProductRule)
//}

/*--------------------------- 1D quadrature rules ------------------------*/

static FLOAT QUAD_1D_P1_wts[] = {
    Dup2(1.)
};
static FLOAT QUAD_1D_P1_pts[Length(QUAD_1D_P1_wts) * 2] = {
    Perm2(.5)
};
QUAD QUAD_1D_P1_ = {
    "1D P1",			/* name */
    1,				/* dim */
    1,				/* order */
    Length(QUAD_1D_P1_wts),	/* npoints */
    QUAD_1D_P1_pts,		/* points */
    QUAD_1D_P1_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_1D_P3_wts[] = {
    Dup11(.5)
};
static FLOAT QUAD_1D_P3_pts[Length(QUAD_1D_P3_wts) * 2] = {
    /* (3 - sqrt(3)) / 6, (3 + sqrt(3)) / 6 */
    Perm11(.21132486540518711774542560974902127)
};
QUAD QUAD_1D_P3_ = {
    "1D P3",			/* name */
    1,				/* dim */
    3,				/* order */
    Length(QUAD_1D_P3_wts),	/* npoints */
    QUAD_1D_P3_pts,		/* points */
    QUAD_1D_P3_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_1D_P5_wts[] = {
    Dup11(5./18.),
    Dup2(4./9.)
};
static FLOAT QUAD_1D_P5_pts[Length(QUAD_1D_P5_wts) * 2] = {
    /* (5 - sqrt(15)) / 10, 1 / 2, (5 + sqrt(15)) / 10 */
    Perm11(.11270166537925831148207346002176004),
    Perm2(.5)
};
QUAD QUAD_1D_P5_ = {
    "1D P5",			/* name */
    1,				/* dim */
    5,				/* order */
    Length(QUAD_1D_P5_wts),	/* npoints */
    QUAD_1D_P5_pts,		/* points */
    QUAD_1D_P5_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_1D_P7_wts[] = {
    /* (18 - sqrt(30)) / 72, (18 + sqrt(30)) / 72 */
    Dup11(.17392742256872692868653197461099970),
    Dup11(.32607257743127307131346802538900030)
};
static FLOAT QUAD_1D_P7_pts[Length(QUAD_1D_P7_wts) * 2] = {
    /* (35 \pm sqrt(525 \pm 70 * sqrt(30))) / 70 */
    Perm11(.06943184420297371238802675555359525),
    Perm11(.33000947820757186759866712044837766)
};
QUAD QUAD_1D_P7_ = {
    "1D P7",			/* name */
    1,				/* dim */
    7,				/* order */
    Length(QUAD_1D_P7_wts),	/* npoints */
    QUAD_1D_P7_pts,		/* points */
    QUAD_1D_P7_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_1D_P9_wts[] = {
    /* (322 \pm 13 * sqrt(70)) / 1800 */
    Dup2(128./450.),
    Dup11(.11846344252809454375713202035995868),
    Dup11(.23931433524968323402064575741781910)
};
static FLOAT QUAD_1D_P9_pts[Length(QUAD_1D_P9_wts) * 2] = {
    /* (21 \pm sqrt(245 \pm 14 * sqrt(70))) / 42 */
    Perm2(0.5),
    Perm11(.04691007703066800360118656085030352),
    Perm11(.23076534494715845448184278964989560)
};
QUAD QUAD_1D_P9_ = {
    "1D P9",			/* name */
    1,				/* dim */
    9,				/* order */
    Length(QUAD_1D_P9_wts),	/* npoints */
    QUAD_1D_P9_pts,		/* points */
    QUAD_1D_P9_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_1D_P11_wts[] = {
    Dup11(.08566224618958517252014807108636645),
    Dup11(.18038078652406930378491675691885806),
    Dup11(.23395696728634552369493517199477550)
};
static FLOAT QUAD_1D_P11_pts[Length(QUAD_1D_P11_wts) * 2] = {
    Perm11(.96623475710157601390615077724699730),
    Perm11(.83060469323313225683069979750995267),
    Perm11(.61930959304159845431525086084035597)
};
QUAD QUAD_1D_P11_ = {
    "1D P11",			/* name */
    1,				/* dim */
    11,				/* order */
    Length(QUAD_1D_P11_wts),	/* npoints */
    QUAD_1D_P11_pts,		/* points */
    QUAD_1D_P11_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_1D_P13_wts[] = {
    Dup11(.06474248308443484663530571633954101),
    Dup11(.13985269574463833395073388571188979),
    Dup11(.19091502525255947247518488774448757),
    Dup2(.20897959183673469387755102040816327)
};
static FLOAT QUAD_1D_P13_pts[Length(QUAD_1D_P13_wts) * 2] = {
    Perm11(.97455395617137926226309484202392563),
    Perm11(.87076559279969721993193238664039420),
    Perm11(.70292257568869858345330320603848073),
    Perm2(.5)
};
QUAD QUAD_1D_P13_ = {
    "1D P13",			/* name */
    1,				/* dim */
    13,				/* order */
    Length(QUAD_1D_P13_wts),	/* npoints */
    QUAD_1D_P13_pts,		/* points */
    QUAD_1D_P13_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_1D_P15_wts[] = {
    Dup11(.05061426814518812957626567715498110),
    Dup11(.11119051722668723527217799721312044),
    Dup11(.15685332293894364366898110099330066),
    Dup11(.18134189168918099148257522463859781)
};
static FLOAT QUAD_1D_P15_pts[Length(QUAD_1D_P15_wts) * 2] = {
    Perm11(.98014492824876811584178043428473650),
    Perm11(.89833323870681336979577696823791522),
    Perm11(.76276620495816449290886952459462317),
    Perm11(.59171732124782490246973807118009199)
};
QUAD QUAD_1D_P15_ = {
    "1D P15",		/* name */
    1,			/* dim */
    15,			/* order */
    Length(QUAD_1D_P15_wts),	/* npoints */
    QUAD_1D_P15_pts,	/* points */
    QUAD_1D_P15_wts,	/* weights */
    -1			/* id */
};

static FLOAT QUAD_1D_P17_wts[] = {
    Dup11(.04063719418078720598594607905526183),
    Dup11(.09032408034742870202923601562145640),
    Dup11(.13030534820146773115937143470931642),
    Dup11(.15617353852000142003431520329222183),
    Dup2(.16511967750062988158226253464348702)
};
static FLOAT QUAD_1D_P17_pts[Length(QUAD_1D_P17_wts) * 2] = {
    Perm11(.98408011975381304491778810145183644),
    Perm11(.91801555366331789714971489403486744),
    Perm11(.80668571635029519865435101967073709),
    Perm11(.66212671170190446451926900732166830),
    Perm2(.5)
};
QUAD QUAD_1D_P17_ = {
    "1D P17",		/* name */
    1,			/* dim */
    17,			/* order */
    Length(QUAD_1D_P17_wts),	/* npoints */
    QUAD_1D_P17_pts,	/* points */
    QUAD_1D_P17_wts,	/* weights */
    -1			/* id */
};

static FLOAT QUAD_1D_P19_wts[] = {
    Dup11(.03333567215434406879678440494666590),
    Dup11(.07472567457529029657288816982884867),
    Dup11(.10954318125799102199776746711408160),
    Dup11(.13463335965499817754561346078473468),
    Dup11(.14776211235737643508694649732566916)
};
static FLOAT QUAD_1D_P19_pts[Length(QUAD_1D_P19_wts) * 2] = {
    Perm11(.98695326425858586003898200604222603),
    Perm11(.93253168334449225536604834421174652),
    Perm11(.83970478414951220311716368255743679),
    Perm11(.71669769706462359539963297158289208),
    Perm11(.57443716949081560544241300056485999)
};
QUAD QUAD_1D_P19_ = {
    "1D P19",		/* name */
    1,			/* dim */
    19,			/* order */
    Length(QUAD_1D_P19_wts),	/* npoints */
    QUAD_1D_P19_pts,	/* points */
    QUAD_1D_P19_wts,	/* weights */
    -1			/* id */
};

static FLOAT QUAD_1D_P21_wts[] = {
    Dup11(.02783428355808683324137686022127429),
    Dup11(.06279018473245231231734714961197005),
    Dup11(.09314510546386712571304882071582795),
    Dup11(.11659688229599523995926185242158757),
    Dup11(.13140227225512333109034443494525460),
    Dup2(.13646254338895031535724176416817109)
};
static FLOAT QUAD_1D_P21_pts[Length(QUAD_1D_P21_wts) * 2] = {
    Perm11(.98911432907302849640196900056142870),
    Perm11(.94353129988404764953757888465196363),
    Perm11(.86507600278702466204670812601557673),
    Perm11(.75954806460340590796286283472930478),
    Perm11(.63477157797617248616576599270043076),
    Perm2(.5)
};
QUAD QUAD_1D_P21_ = {
    "1D P21",		/* name */
    1,			/* dim */
    21,			/* order */
    Length(QUAD_1D_P21_wts),	/* npoints */
    QUAD_1D_P21_pts,	/* points */
    QUAD_1D_P21_wts,	/* weights */
    -1			/* id */
};

/*--------------------------- 2D cubature rules ------------------------*/

static FLOAT QUAD_2D_P1_wts[] = {
    Dup3(1.)
};
static FLOAT QUAD_2D_P1_pts[Length(QUAD_2D_P1_wts) * 3] = {
    Perm3(1./3.)
};
QUAD QUAD_2D_P1_ = {
    "2D P1",			/* name */
    2,				/* dim */
    1,				/* order */
    Length(QUAD_2D_P1_wts),	/* npoints */
    QUAD_2D_P1_pts,		/* points */
    QUAD_2D_P1_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_2D_P2_wts[] = {
    Dup21(1./3.)
};
static FLOAT QUAD_2D_P2_pts[Length(QUAD_2D_P2_wts) * 3] = {
    Perm21(1./6.)
};
QUAD QUAD_2D_P2_ = {
    "2D P2",			/* name */
    2,				/* dim */
    2,				/* order */
    Length(QUAD_2D_P2_wts),	/* npoints = 3 */
    QUAD_2D_P2_pts,		/* points */
    QUAD_2D_P2_wts,		/* weights */
    -1				/* id */
};

#if 0
/* Note: this rule has points on the edges */
static FLOAT QUAD_2D_P3_wts[] = {
    Dup21(1./30.),
    Dup21(3./10.)
};
static FLOAT QUAD_2D_P3_pts[Length(QUAD_2D_P3_wts) * 3] = {
    Perm21(.5),
    /* 1/6 */
    Perm21(1./6.)
};
#else
static FLOAT QUAD_2D_P3_wts[] = {
    Dup21(.28114980244097964825351432270207695),
    Dup21(.05218353089235368507981901063125638)
};
static FLOAT QUAD_2D_P3_pts[Length(QUAD_2D_P3_wts) * 3] = {
    Perm21(.16288285039589191090016180418490635),
    Perm21(.47791988356756370000000000000000000)
};
#endif
QUAD QUAD_2D_P3_ = {
    "2D P3",			/* name */
    2,				/* dim */
    3,				/* order */
    Length(QUAD_2D_P3_wts),	/* npoints = 6 */
    QUAD_2D_P3_pts,		/* points */
    QUAD_2D_P3_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_2D_P4_wts[] = {
    /* (620 + sqrt(213125 - 53320 * sqrt(10))) / 3720 */
    Dup21(.22338158967801146569500700843312280),
    /* (620 - sqrt(213125 - 53320 * sqrt(10))) / 3720 */
    Dup21(.10995174365532186763832632490021053)
};
static FLOAT QUAD_2D_P4_pts[Length(QUAD_2D_P4_wts) * 3] = {
    /* (8 - sqrt(10) + sqrt(38 - 44 * sqrt(2 / 5))) / 18 */
    Perm21(.44594849091596488631832925388305199),
    /* (8 - sqrt(10) - sqrt(38 - 44 * sqrt(2 / 5))) / 18 */
    Perm21(.09157621350977074345957146340220151)
};
QUAD QUAD_2D_P4_ = {
    "2D P4",			/* name */
    2,				/* dim */
    4,				/* order */
    Length(QUAD_2D_P4_wts),	/* npoints = 6 */
    QUAD_2D_P4_pts,		/* points */
    QUAD_2D_P4_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_2D_P5_wts[] = {
    /* (155 - sqrt(15)) / 1200 */
    Dup21(.12593918054482715259568394550018133),
    /* (155 + sqrt(15)) / 1200 */
    Dup21(.13239415278850618073764938783315200),
    Dup3(9./40.)
};
static FLOAT QUAD_2D_P5_pts[Length(QUAD_2D_P5_wts) * 3] = {
    /* (6 - sqrt(15)) / 21 */
    Perm21(.10128650732345633880098736191512383),
    /* (6 + sqrt(15)) / 21 */
    Perm21(.47014206410511508977044120951344760),
    /* 1 / 3 */
    Perm3(1./3.)
};
QUAD QUAD_2D_P5_ = {
    "2D P5",			/* name */
    2,				/* dim */
    5,				/* order */
    Length(QUAD_2D_P5_wts),	/* npoints = 7 */
    QUAD_2D_P5_pts,		/* points */
    QUAD_2D_P5_wts,		/* weights */
    -1				/* id */
};

/* Note: an 11-point rule has been found in:
 *	 Day, David M., Mark A. Taylor, "A new 11 point degree 6 cubature
 *	 	formula for the triangle [Proceedings of the ICIAM 2007],"
 *	 Journal Article, Proceedings of Applied Mathematics and Mechanics,
 *	 Accepted/Published January 2008. */
static FLOAT QUAD_2D_P6_wts[] = {
    Dup21(.05084490637020681692093680910686898),
    Dup21(.11678627572637936602528961138557944),
    Dup111(.08285107561837357519355345642044245)
};
static FLOAT QUAD_2D_P6_pts[Length(QUAD_2D_P6_wts) * 3] = {
    Perm21(.06308901449150222834033160287081916),
    Perm21(.24928674517091042129163855310701908),
    Perm111(.05314504984481694735324967163139815,
	    .31035245103378440541660773395655215)
};
QUAD QUAD_2D_P6_ = {
    "2D P6",			/* name */
    2,				/* dim */
    6,				/* order */
    Length(QUAD_2D_P6_wts),	/* npoints = 12 */
    QUAD_2D_P6_pts,		/* points */
    QUAD_2D_P6_wts,		/* weights */
    -1				/* id */
};

#if 0
static FLOAT QUAD_2D_P7_wts[] = {
    Dup21(0.0102558174092),
    Dup111(0.1116047046647),
    Dup21(0.1679775595335),
    Dup21(0.2652238803946)
};
static FLOAT QUAD_2D_P7_pts[Length(QUAD_2D_P7_wts) * 3] = {
    Perm21(0.),
    Perm111(0.7839656651012, 0.1738960507345),
    Perm21(0.4743880861752),
    Perm21(0.2385615300181)
};
#else
static FLOAT QUAD_2D_P7_wts[] = {
    Dup21(.01353386251566556156682309245259393),
    Dup21(.07895125443201098137652145029770332),
    Dup21(.12860792781890607455665553308952344),
    Dup111(.05612014428337535791666662874675632)
};
static FLOAT QUAD_2D_P7_pts[Length(QUAD_2D_P7_wts) * 3] = {
    Perm21(.02826392415607634022359600691324002),
    Perm21(.47431132326722257527522522793181654),
    Perm21(.24114332584984881025414351267036207),
    Perm111(.76122274802452380000000000000000000,
	    .04627087779880891064092559391702049)
};
#endif
QUAD QUAD_2D_P7_ = {
    "2D P7",			/* name */
    2,				/* dim */
    7,				/* order */
    Length(QUAD_2D_P7_wts),	/* npoints = 15 */
    QUAD_2D_P7_pts,		/* points */
    QUAD_2D_P7_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_2D_P8_wts[] = {
    Dup3(.14431560767778716825109111048906462),
    Dup21(.10321737053471825028179155029212903),
    Dup21(.03245849762319808031092592834178060),
    Dup21(.09509163426728462479389610438858432),
    Dup111(.02723031417443499426484469007390892)
};
static FLOAT QUAD_2D_P8_pts[Length(QUAD_2D_P8_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.17056930775176020662229350149146450),
    Perm21(.05054722831703097545842355059659895),
    Perm21(.45929258829272315602881551449416932),
    Perm111(.26311282963463811342178578628464359,
	    .00839477740995760533721383453929445)
};
QUAD QUAD_2D_P8_ = {
    "2D P8",			/* name */
    2,				/* dim */
    8,				/* order */
    Length(QUAD_2D_P8_wts),	/* npoints = 16 */
    QUAD_2D_P8_pts,		/* points */
    QUAD_2D_P8_wts,		/* weights */
    -1				/* id */
};

#if 0
static FLOAT QUAD_2D_P9_wts[] = {
    Dup21(0.0519871420646),
    Dup111(0.0707034101784),
    Dup111(0.0909390760952),
    Dup21(0.1032344051380),
    Dup21(0.1881601469167)
};
static FLOAT QUAD_2D_P9_pts[Length(QUAD_2D_P9_wts) * 3] = {
    Perm21(0.0451890097844),
    Perm111(0.7475124727339, 0.2220631655373),
    Perm111(0.1369912012649, 0.2182900709714),
    Perm21(0.4815198347833),
    Perm21(0.4036039798179)
};
QUAD QUAD_2D_P9_ = {
    "2D P9",			/* name */
    2,				/* dim */
    9,				/* order */
    21,				/* npoints */
    QUAD_2D_P9_pts,		/* points */
    QUAD_2D_P9_wts,		/* weights */
    -1				/* id */
};
#else
static FLOAT QUAD_2D_P9_wts[] = {
    Dup3(.09713579628279883381924198250728863),
    Dup21(.03133470022713907053685483128720932),
    Dup21(.02557767565869803126167879855899982),
    Dup21(.07782754100477427931673935629940396),
    Dup21(.07964773892721025303289177426404527),
    Dup111(.04328353937728937728937728937728938)
};
static FLOAT QUAD_2D_P9_pts[Length(QUAD_2D_P9_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.48968251919873762778370692483619280),
    Perm21(.04472951339445270986510658996627636),
    Perm21(.43708959149293663726993036443535497),
    Perm21(.18820353561903273024096128046733557),
    Perm111(.74119859878449802069007987352342383,
	    .22196298916076569567510252769319107)
};
QUAD QUAD_2D_P9_ = {
    "2D P9",			/* name */
    2,				/* dim */
    9,				/* order */
    Length(QUAD_2D_P9_wts),	/* npoints = 19 */
    QUAD_2D_P9_pts,		/* points */
    QUAD_2D_P9_wts,		/* weights */
    -1				/* id */
};
#endif

static FLOAT QUAD_2D_P10_wts[] = {
    Dup3(.08093742879762288025711312381650193),
    Dup21(.07729858800296312168250698238034344),
    Dup21(.07845763861237173136809392083439673),
    Dup21(.01746916799592948691760716329067815),
    Dup21(.00429237418483282803048040209013191),
    Dup111(.03746885821046764297902076548504452),
    Dup111(.02694935259187995964544947958109671)
};
static FLOAT QUAD_2D_P10_pts[Length(QUAD_2D_P10_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.42727317884677553809044271751544715),
    Perm21(.18309922244867502052157438485022004),
    Perm21(.49043401970113058745397122237684843),
    Perm21(.01257244555158053273132908502104126),
    Perm111(.65426866792006614066657009558762790,
	    .30804600168524770000000000000000000),
    Perm111(.12280457706855927343012981748128116,
	    .03337183373930478624081644177478038)
};
QUAD QUAD_2D_P10_ = {
    "2D P10",			/* name */
    2,				/* dim */
    10,				/* order */
    Length(QUAD_2D_P10_wts),	/* npoints = 25 */
    QUAD_2D_P10_pts,		/* points */
    QUAD_2D_P10_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_2D_P11_wts[] = {
    Dup3(.08117796029686715951547596874982357),
    Dup21(.01232404350690949411847390101623284),
    Dup21(.06282800974441010728333942816029398),
    Dup21(.01222037904936452975521221500393789),
    Dup21(.06770134895281150992098886182322559),
    Dup21(.04021969362885169042356688960756866),
    Dup111(.01476227271771610133629306558778206),
    Dup111(.04072799645829903966033695848161786)
};
static FLOAT QUAD_2D_P11_pts[Length(QUAD_2D_P11_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.03093835524543078489519501499130475),
    Perm21(.43649818113412884191761527655997324),
    Perm21(.49898476370259326628798698383139087),
    Perm21(.21468819795859433660687581387825086),
    Perm21(.11368310404211339020529315622836178),
    Perm111(.82561876616486290435880620030835800,
	    .15974230459185018980086078822500751),
    Perm111(.64047231013486526767703659081896681,
	    .31178371570959900000000000000000000)
};
QUAD QUAD_2D_P11_ = {
    "2D P11",			/* name */
    2,				/* dim */
    11,				/* order */
    Length(QUAD_2D_P11_wts),	/* npoints = 28 */
    QUAD_2D_P11_pts,		/* points */
    QUAD_2D_P11_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_2D_P12_wts[] = {
    Dup21(.00616626105155901723386648378523035),
    Dup21(.06285822421788510035427051309288255),
    Dup21(.03479611293070894298932839729499937),
    Dup21(.04369254453803840213545726255747497),
    Dup21(.02573106644045533541779092307156443),
    Dup111(.02235677320230344571183907670231999),
    Dup111(.01731623110865889237164210081103407),
    Dup111(.04037155776638092951782869925223677)
};
static FLOAT QUAD_2D_P12_pts[Length(QUAD_2D_P12_wts) * 3] = {
    Perm21(.02131735045321037024685697551572825),
    Perm21(.27121038501211592234595134039689474),
    Perm21(.12757614554158592467389632515428357),
    Perm21(.43972439229446027297973662348436108),
    Perm21(.48821738977380488256466206525881104),
    Perm111(.69583608678780342214163552323607254,
	    .28132558098993954824813069297455275),
    Perm111(.85801403354407263059053661662617818,
	    .11625191590759714124135414784260182),
    Perm111(.60894323577978780685619243776371007,
	    .27571326968551419397479634607976398)
};
QUAD QUAD_2D_P12_ = {
    "2D P12",			/* name */
    2,				/* dim */
    12,				/* order */
    Length(QUAD_2D_P12_wts),	/* npoints = 33 */
    QUAD_2D_P12_pts,		/* points */
    QUAD_2D_P12_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_2D_P13_wts[] = {
    Dup3(.06796003658683164428177442468088488),
    Dup21(.05560196753045332870725746601046147),
    Dup21(.05827848511919998140476708351333981),
    Dup21(.00605233710353917184179280003229082),
    Dup21(.02399440192889473077371079945095965),
    Dup111(.03464127614084837046598682851091822),
    Dup111(.01496540110516566726324585713290344),
    Dup111(.02417903981159381913744574557306076),
    Dup111(.00959068100354326272259509016611089)
};
static FLOAT QUAD_2D_P13_pts[Length(QUAD_2D_P13_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.42694141425980040602081253503137421),
    Perm21(.22137228629183290065481255470507908),
    Perm21(.02150968110884318386929131353405208),
    Perm21(.48907694645253934990068971909020439),
    Perm111(.62354599555367557081585435318623659,
	    .30844176089211777465847185254124531),
    Perm111(.86470777029544277530254595089569318,
	    .11092204280346339541286954522167452),
    Perm111(.74850711589995219517301859578870965,
	    .16359740106785048023388790171095725),
    Perm111(.72235779312418796526062013230478405,
	    .27251581777342966618005046435408685)
};
QUAD QUAD_2D_P13_ = {
    "2D P13",			/* name */
    2,				/* dim */
    13,				/* order */
    Length(QUAD_2D_P13_wts),	/* npoints = 37 */
    QUAD_2D_P13_pts,		/* points */
    QUAD_2D_P13_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_2D_P14_wts[] = {
    Dup3(.05859628522602859412789380634775601),
    Dup21(.00173515122972526756806186388080941),
    Dup21(.02616378255861452177782885918197827),
    Dup21(.00391972924240182909652082757014540),
    Dup21(.01224735975694086609728698992625048),
    Dup21(.02819962850325796010736630715156571),
    Dup21(.05088708718595948529603482754545404),
    Dup21(.05045343990160359919102089713411889),
    Dup111(.01706364421223345129002539938494722),
    Dup111(.00968346642550660040752096309341938),
    Dup111(.03638575592848500562201132776427165),
    Dup111(.00696466337351841242539972250424131)
};
static FLOAT QUAD_2D_P14_pts[Length(QUAD_2D_P14_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.00997976080645843241529352958205243),
    Perm21(.47997789352118838981055286508838991),
    Perm21(.15381195917696690000000000000000000),
    Perm21(.07402347711698781000000000000000000),
    Perm21(.13035468250333000000000000000000000),
    Perm21(.23061722602665313429960537009838312),
    Perm21(.42233208341914782411440871379139388),
    Perm111(.78623738593466100332962211403309001,
	    .19061636003190090424614328286530343),
    Perm111(.63055214366060744162240907556881292,
	    .36232313774354714461832673435977294),
    Perm111(.62657732985630631423351231375342650,
	    .29077120588366741502481681748167319),
    Perm111(.91420998492962541223996709938504695,
	    .07116571087775076254759245029243364)
};
QUAD QUAD_2D_P14_ = {
    "2D P14",			/* name */
    2,				/* dim */
    14,				/* order */
    Length(QUAD_2D_P14_wts),	/* npoints = 46 */
    QUAD_2D_P14_pts,		/* points */
    QUAD_2D_P14_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_2D_P15_wts[] = {
    Dup3(.04403871087843427985301732721493388),
    Dup21(.04618478718202697994871566760191669),
    Dup21(.00649890661733271652688280349281019),
    Dup21(.01799361425265840324466992416715655),
    Dup21(.04177310503914135411968606056414597),
    Dup21(.00305954760911646654843016992834484),
    Dup21(.00201243505255864734409031875654046),
    Dup21(.01677561093050912232611145688795876),
    Dup111(.01546074918971427486608803040924742),
    Dup111(.02849989033954742339273955875330195),
    Dup111(.03209435048348959564209923573709566),
    Dup111(.01150858163687071128402324377324186),
    Dup111(.00461430652896710314358717609185406)
};
static FLOAT QUAD_2D_P15_pts[Length(QUAD_2D_P15_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.22733221881914287420250436849229406),
    Perm21(.49716257743188742987380980001602329),
    Perm21(.47884973534895458333922920014385258),
    Perm21(.40498603909827199169724464234269204),
    Perm21(.01593121667174443211342773294126896),
    Perm21(.16558326242608140000000000000000000),
    Perm21(.07313360471922872772687381210732441),
    Perm111(.66526073307221393906236441338569119,
	    .31635283934494723008633813095024529),
    Perm111(.71252198724254553304884901162338783,
	    .09346075114991753000000000000000047),
    Perm111(.55964836223539321841224845401923000,
	    .34422901758219320000000000000000160),
    Perm111(.81047659761907686304683273029057126,
	    .17104724831425795154765033192558481),
    Perm111(.91607564403173118856460883877832000,
	    .07305599647918648961294908192742498)
};
QUAD QUAD_2D_P15_ = {
    "2D P15",			/* name */
    2,				/* dim */
    15,				/* order */
    Length(QUAD_2D_P15_wts),	/* npoints = 52 */
    QUAD_2D_P15_pts,		/* points */
    QUAD_2D_P15_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_2D_P16_wts[] = {
    Dup3(.04802218868037709055183940458051988),
    Dup21(.01470910030680192710340364286186919),
    Dup21(.02954458654931925599530972679646409),
    Dup21(.02612501735108837749859756549171557),
    Dup21(.00278038735239000697500301613866207),
    Dup21(.03182177300053664950342729005594961),
    Dup21(.00864583434950965990117373416984893),
    Dup111(.01430033290449536514661642536825213),
    Dup111(.02784977720360082995222987342395349),
    Dup111(.00704167340663609756237018808928069),
    Dup111(.01789983825993372860177020907581078),
    Dup111(.02745820038434976307247003810091720),
    Dup111(.00729979693943176208411254408777766)
};
static FLOAT QUAD_2D_P16_pts[Length(QUAD_2D_P16_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.08179498313137387264146559311886101),
    Perm21(.16530060196977965062676193293355656),
    Perm21(.46859210534946138669460289729660561),
    Perm21(.01443881344541668261410895669566020),
    Perm21(.24178428539178335340689445929320769),
    Perm21(.49531034298776996406549508687740551),
    Perm111(.65051340266135229943114468484168666,
	    .33139974453708955658132316818259388),
    Perm111(.60401128149599703984940410303596702,
	    .30324716274994218504155217807834692),
    Perm111(.80216825757474166361686194781166705,
	    .18802805952123717344418211429398875),
    Perm111(.75650560644282839655115407575806082,
	    .18350466852229686368238027743700035),
    Perm111(.46593843871411818488381073359154639,
	    .35964594879750460000000000000001000),
    Perm111(.90639484399204150136249966186534000,
	    .07719437129575543228251522505271386)
};
QUAD QUAD_2D_P16_ = {
    "2D P16",			/* name */
    2,				/* dim */
    16,				/* order */
    Length(QUAD_2D_P16_wts),	/* npoints = 55 */
    QUAD_2D_P16_pts,		/* points */
    QUAD_2D_P16_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_2D_P17_wts[] = {
    Dup3(.04475687144434462937183647670425513),
    Dup21(.01736688502674779645049111764776038),
    Dup21(.03059934807610353272266564726895704),
    Dup21(.02858770857859978020704009121768920),
    Dup21(.00664743192975369323231849554546676),
    Dup21(.00747618940201851182224557347080098),
    Dup21(.02504998650383874531455895190550778),
    Dup111(.00147981089211964494480953682750477),
    Dup111(.00512113624674810606589435040573260),
    Dup111(.02731735936959280591853168984239567),
    Dup111(.01400572867590928159786633211401179),
    Dup111(.00780927569745836009810987323288001),
    Dup111(.01816572845979167217607207751722372),
    Dup111(.02744437399245832776208345541478450)
};
static FLOAT QUAD_2D_P17_pts[Length(QUAD_2D_P17_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.09569850886271093994316257860237634),
    Perm21(.17013863967877544672324723079568443),
    Perm21(.41802068586795497622263464239342782),
    Perm21(.49658148050662495497054035306227918),
    Perm21(.04166211482880764279207885159834192),
    Perm21(.46793290572942357826819008536171190),
    Perm111(.96953119890372205619454058305953242,
	    .02892509162021824607152804771406821),
    Perm111(.75972438753862412955532719532266120,
	    .23444175526356877454266053091297880),
    Perm111(.29549931696830150000000000000001000,
	    .49591124666075357542303450004375516),
    Perm111(.62560638215769702707019209266693705,
	    .35341769454149706762632499077099377),
    Perm111(.87217444723318479290318300141560742,
	    .11272864181421976861888886768074196),
    Perm111(.74751231944000604006240678176087530,
	    .19907027879785788131339143981558306),
    Perm111(.59886879088323805980616769726351095,
	    .30358518307132607653202051204584937)
};
QUAD QUAD_2D_P17_ = {
    "2D P17",			/* name */
    2,				/* dim */
    17,				/* order */
    Length(QUAD_2D_P17_wts),	/* npoints = 61 */
    QUAD_2D_P17_pts,		/* points */
    QUAD_2D_P17_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_2D_P18_wts[] = {
    Dup21(.01397786164528602097958400799055493),
    Dup21(.00055490697921321378506845551525090),
    Dup21(.02102681381970466902842986851624498),
    Dup21(.03401821217992769974722652741822109),
    Dup111(.02791016580477499514184347400781694),
    Dup111(.01821468612715086612673395662068577),
    Dup111(.01426702365810979307751982410955666),
    Dup111(.01423712309067505070431276377415596),
    Dup111(.01925758385467478779913738368202133),
    Dup111(.00970513228438064114878227633239023),
    Dup111(.00762978813433212899578245563385336),
    Dup111(.01061873913635034479446354367052828),
    Dup111(.00571066980327583881341421438268949),
    Dup111(.00432685746087641829452234473283270)
};
static FLOAT QUAD_2D_P18_pts[Length(QUAD_2D_P18_wts) * 3] = {
    Perm21(.07327088646438283157861967148768954),
    Perm21(.00391774898322823164278407441958060),
    Perm21(.46759731898871106165151299662296245),
    Perm21(.41791621096741131201212681051399350),
    Perm111(.16538169336028948005449026923917662,
	    .56369670566087075380514589393807372),
    Perm111(.28750089440578398999619391313966060,
	    .28604232613920474912095810748030295),
    Perm111(.12588931431982479601706483994903803,
	    .69604321864246119579257486028195390),
    Perm111(.06322191594650261449357508011699804,
	    .76054555188768243261459476379786871),
    Perm111(.07891022745402051775207221037548892,
	    .59201963127175856332262057540222541),
    Perm111(.03805805350678571432611899159626213,
	    .68368125963599985248012408745381310),
    Perm111(.01429035213045402564992411031307492,
	    .85170403713705581502852165344276639),
    Perm111(.01296727234325317231234163433009032,
	    .57473249288814902889945093868968971),
    Perm111(.00764859482084089933079262881822729,
	    .73551044083072929870313522448164061),
    Perm111(.01271046057225546793114249181358220,
	    .93934508764373178870740420268282255)
};
QUAD QUAD_2D_P18_ = {
    "2D P18",			/* name */
    2,				/* dim */
    18,				/* order */
    Length(QUAD_2D_P18_wts),	/* npoints = 72 */
    QUAD_2D_P18_pts,		/* points */
    QUAD_2D_P18_wts,		/* weights */
    -1				/* id */
};

/* Note: the rule QUAD_2D_P19 was taken from the book by
 *	P. Solin, K. Segeth, and I. Dolezel,
 *	"Higer-order Finite Element Methods",
 *	Chapman and Hall/CRC Press, 2003. */
static FLOAT QUAD_2D_P19_wts[] = {
    Dup3(.03290633138891865208361434484647497),
    Dup21(.01033073189127205336703996357174833),
    Dup21(.02238724726301639252918455603516271),
    Dup21(.03026612586946807086528019098259122),
    Dup21(.03049096780219778100003158657852042),
    Dup21(.02415921274164090491184803098664001),
    Dup21(.01605080358680087529162277027642948),
    Dup21(.00808458026178406048180567324219442),
    Dup21(.00207936202748478075134750167439841),
    Dup111(.00388487690498138975670499199277266),
    Dup111(.02557416061202190389292970195260027),
    Dup111(.00888090357333805774552592470351753),
    Dup111(.01612454676173139121978526932783766),
    Dup111(.00249194181749067544058464757594956),
    Dup111(.01824284011895057837766571320973615),
    Dup111(.01025856373619852130804807004235813),
    Dup111(.00379992885530191397907315371363970)
};
static FLOAT QUAD_2D_P19_pts[Length(QUAD_2D_P19_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.48960998707300633196613106574829817),
    Perm21(.45453689269789266204675939053572830),
    Perm21(.40141668064943118739399562381068860),
    Perm21(.25555165440309761132218176810926787),
    Perm21(.17707794215212955164267520651590115),
    Perm21(.11006105322795186130008495167737397),
    Perm21(.05552862425183967124867841247135571),
    Perm21(.01262186377722866849023476677870599),
    Perm111(.60063379479464500000000000000000000,
	    .39575478735694286230479469406582787),
    Perm111(.13446675453077978561204319893264695,
	    .55760326158878396836395324250118097),
    Perm111(.72098702581736505521665290233827892,
	    .26456694840652020804030173490121494),
    Perm111(.59452706895587092461388928802650670,
	    .35853935220595058842492699064590088),
    Perm111(.83933147368083857861749007714840520,
	    .15780740596859474473767360335950651),
    Perm111(.22386142409791569130336938950653642,
	    .70108797892617336732328833655951158),
    Perm111(.82293132406985663162747155916053316,
	    .14242160111338343731557475687723745),
    Perm111(.92434425262078402945585913790156314,
	    .06549462808293770339232652498592557)
};
QUAD QUAD_2D_P19_ = {
    "2D P19",			/* name */
    2,				/* dim */
    19,				/* order */
    Length(QUAD_2D_P19_wts),	/* npoints = 73 */
    QUAD_2D_P19_pts,		/* points */
    QUAD_2D_P19_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_2D_P20_wts[] = {
    Dup3(.01253760799449665657358563677239480),
    Dup21(.02747186987642421374845354960735985),
    Dup21(.00976527227705142304136469142942368),
    Dup21(.00139841953539182352392336315978673),
    Dup21(.00929210262518518263042820340303303),
    Dup21(.01657787603236692532602362503518398),
    Dup111(.02066776234866507696142197001297288),
    Dup111(.02082223552115450730687855619932975),
    Dup111(.00956863841984906068887584504583203),
    Dup111(.02445277096897246388564392070240889),
    Dup111(.00315573063063053400382640032072957),
    Dup111(.01213679636532129693701330908075738),
    Dup111(.01496648014388644903652491185157070),
    Dup111(.00632759332177773956932403275043979),
    Dup111(.00134256031206369588497985129814333),
    Dup111(.00277607691634755406772935615580153),
    Dup111(.01073984447418494155517344744795167),
    Dup111(.00536780573818745320524741002126972)
};
static FLOAT QUAD_2D_P20_pts[Length(QUAD_2D_P20_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.21587430593299197319025454384018276),
    Perm21(.07537676652974727809728543094591628),
    Perm21(.01030082813722179211368621600969694),
    Perm21(.49360221129870016551192083214505357),
    Perm21(.46155093810692529674104871029151803),
    Perm111(.32862140642423699330349746095091325,
	    .42934057025821037521395880046639840),
    Perm111(.26048036178656875641959301708115346,
	    .10157753428096944616875500619617966),
    Perm111(.13707423584645530000000000000000000,
	    .71006597300113015998790407454640790),
    Perm111(.14672694587229978430416098848745303,
	    .49854547767841484938962269670761193),
    Perm111(.02699897774255329000000000000000000,
	    .04918672267258200161970371257758717),
    Perm111(.06187178593361702684171247001223384,
	    .77966014654056939536035061907681080),
    Perm111(.04772436742762199620835268010429344,
	    .37049153914954763692014962025673877),
    Perm111(.12060051518636437996723378704007933,
	    .86334694875475264849798799609252174),
    Perm111(.00269714779670978767164891450128273,
	    .05619493818774550298789230198658868),
    Perm111(.00301563327794236265727625982347101,
	    .20867500674842135095759446306135771),
    Perm111(.02990537578845701880692877386433865,
	    .72115124091203409102810415020509411),
    Perm111(.00675665422246098853994581751922784,
	    .64005544194054188990405366827216467)
};
QUAD QUAD_2D_P20_ = {
    "2D P20",                   /* name */
    2,                          /* dim */
    20,                         /* order */
    Length(QUAD_2D_P20_wts),    /* npoints = 88 */
    QUAD_2D_P20_pts,            /* points */
    QUAD_2D_P20_wts,            /* weights */
    -1                          /* id */
};

static FLOAT QUAD_2D_P21_wts[] = {
    Dup3(.02756225695287648096690704482451431),
    Dup21(.02206021541348850119135073403311636),
    Dup21(.02346001593867148849301344495230002),
    Dup21(.00032688959504719054621455750154654),
    Dup21(.00326531946293996823433530409586668),
    Dup21(.01175646291541279770430796921338205),
    Dup21(.01178076841991151684555757909867614),
    Dup111(.00226881081880114080533570433430431),
    Dup111(.00259601096443632006067378366548822),
    Dup111(.00463452978587186021234789056159687),
    Dup111(.00479433605454885793485744871991192),
    Dup111(.00571247883672361156725063834296336),
    Dup111(.00586582760432212163695579870000227),
    Dup111(.00941376305909158758981826852034708),
    Dup111(.01341494379665642491002202661089309),
    Dup111(.01571691809208324594350000113784617),
    Dup111(.01686368301443690459165096388619991),
    Dup111(.02139002708532009837783229808035898),
    Dup111(.02307679218949268136788087552189154)
};
static FLOAT QUAD_2D_P21_pts[Length(QUAD_2D_P21_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.20093527706508527987296185156416367),
    Perm21(.43765916596192717973183384418805413),
    Perm21(.00343395649059617685095991220960492),
    Perm21(.04664348477530675349517624043214192),
    Perm21(.38642225176307149094035202416772642),
    Perm21(.09543547110853091010857168104147605),
    Perm111(.95551380335045636050131472514677118,
	    .03571862787316335823804160897543867),
    Perm111(.88663881342886822612490057469143760,
	    .10814322491564621152738861104631270),
    Perm111(.78426284588043415429664399039819537,
	    .20746444959987645682438042951572740),
    Perm111(.88292395505020003271134898731688967,
	    .08568470872031694000000000000001000),
    Perm111(.66899196444107724049132248320989459,
	    .32149400301428881688168321268348603),
    Perm111(.55207212103556096415716096525277878,
	    .43794221879334138355236807696291701),
    Perm111(.79759296559656856762931422329572582,
	    .16191645306357785675100677020385905),
    Perm111(.67751471511977148463499116634413256,
	    .27450476740199490385900297290733317),
    Perm111(.54299741558909160533113611683919342,
	    .40533599807500692794989089537632556),
    Perm111(.70545990556996856165885634154060172,
	    .18773768065643534277281674394512005),
    Perm111(.57480057306650846221598245054985001,
	    .30569683476605516651279255664984316),
    Perm111(.47177880850461481660397704013492420,
	    .31214446687089088167080460581557645)
};
QUAD QUAD_2D_P21_ = {
    "2D P21",			/* name */
    2,				/* dim */
    21,				/* order */
    Length(QUAD_2D_P21_wts),	/* npoints = 91 */
    QUAD_2D_P21_pts,		/* points */
    QUAD_2D_P21_wts,		/* weights */
    -1				/* id */
};

/*---------------------------- 3D cubature rules ---------------------------*/

static FLOAT QUAD_3D_P1_wts[] = {
    Dup4(1.)
};
static FLOAT QUAD_3D_P1_pts[Length(QUAD_3D_P1_wts) * 4] = {
    Perm4(.25)
};
QUAD QUAD_3D_P1_ = {
    "3D P1",			/* name */
    3,				/* dim */
    1,				/* order */
    Length(QUAD_3D_P1_wts),	/* npoints = 1 */
    QUAD_3D_P1_pts,		/* points */
    QUAD_3D_P1_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_3D_P2_wts[] = {
    Dup31(.25)
};
static FLOAT QUAD_3D_P2_pts[Length(QUAD_3D_P2_wts) * 4] = {
    /* (5. - sqrt(5.)) / 20, (5. + 3 * sqrt(5.)) / 20 */
    Perm31(.13819660112501051517954131656343619)
};
QUAD QUAD_3D_P2_ = {
    "3D P2",			/* name */
    3,				/* dim */
    2,				/* order */
    Length(QUAD_3D_P2_wts),	/* npoints = 4 */
    QUAD_3D_P2_pts,		/* points */
    QUAD_3D_P2_wts,		/* weights */
    -1				/* id */
};

#if 0
static FLOAT QUAD_3D_P3_wts[] = {
    Dup31(1./40.),
    Dup31(9./40.)
};
static FLOAT QUAD_3D_P3_pts[Length(QUAD_3D_P3_wts) * 4] = {
    Perm31(0., 1.),
    Perm31(1./3., 0.)
};
#else
static FLOAT QUAD_3D_P3_wts[] = {
    /* 1 / 8 + sqrt((1715161837 - 406006699 * sqrt(17)) / 23101) / 3120 */
    Dup31(.13852796651186214232361769837564129),
    /* 1 / 8 - sqrt((1715161837 - 406006699 * sqrt(17)) / 23101) / 3120 */
    Dup31(.11147203348813785767638230162435871)
};
static FLOAT QUAD_3D_P3_pts[Length(QUAD_3D_P3_wts) * 4] = {
    /* (55 - 3 * sqrt(17) + sqrt(1022 - 134 * sqrt(17))) / 196 */
    Perm31(.32805469671142664733580581998119743),
    /* (55 - 3 * sqrt(17) - sqrt(1022 - 134 * sqrt(17))) / 196 */
    Perm31(.10695227393293068277170204157061650)
};
#endif
QUAD QUAD_3D_P3_ = {
    "3D P3",			/* name */
    3,				/* dim */
    3,				/* order */
    Length(QUAD_3D_P3_wts),	/* npoints = 8 */
    QUAD_3D_P3_pts,		/* points */
    QUAD_3D_P3_wts,		/* weights */
    -1				/* id */
};

#if 0
static FLOAT QUAD_3D_P4_wts[] = {
    Dup4(-148./1875.),	/* negative weight */
    Dup31(343./7500.),
    Dup22(56./375.)
};
static FLOAT QUAD_3D_P4_pts[Length(QUAD_3D_P4_wts) * 4] = {
    Perm4(0.25),
    Perm31(1./14.),
    Perm22(0.1005964238332008)
};
QUAD QUAD_3D_P4_ = {
    "3D P4",			/* name */
    3,				/* dim */
    4,				/* order */
    11,				/* npoints */
    QUAD_3D_P4_pts,		/* points */
    QUAD_3D_P4_wts,		/* weights */
    -1				/* id */
};
#else
static FLOAT QUAD_3D_P4_wts[] = {
    Dup31(.07349304311636194934358694586367885),
    Dup31(.11268792571801585036501492847638892),
    Dup22(.04254602077708146686093208377328816)
};
static FLOAT QUAD_3D_P4_pts[Length(QUAD_3D_P4_wts) * 4] = {
    Perm31(.09273525031089122628655892066032137),
    Perm31(.31088591926330060975814749494040332),
    Perm22(.04550370412564965000000000000000000)
};
QUAD QUAD_3D_P4_ = {
    "3D P4",			/* name */
    3,				/* dim */
    4,				/* order */
    Length(QUAD_3D_P4_wts),	/* npoints = 14 */
    QUAD_3D_P4_pts,		/* points */
    QUAD_3D_P4_wts,		/* weights */
    -1				/* id */
};
#endif

#if 0
/* Stroud T3:5-1 p315 */
static FLOAT QUAD_3D_P5_wts[] = {
    Dup4(16./135.),
    /* (2665 + 14 * sqrt(15)) / 37800 */
    Dup31(.07193708377901862),
    /* (2665 - 14 * sqrt(15)) / 37800 */
    Dup31(.06906820722627239),
    Dup22(20./378.)
};
static FLOAT QUAD_3D_P5_pts[Length(QUAD_3D_P5_wts) * 4] = {
    Perm4(.25),
    /* (7 - sqrt(15)) / 34, (13 + 3 * sqrt(15)) / 34 */
    Perm31(.09197107805272303),
    /* (7 + sqrt(15)) / 34, (13 - 3 * sqrt(15)) / 34 */
    Perm31(.31979362782962991),
    /* (10 - 2 * sqrt(15)) / 40, (10 + 2 * sqrt(15)) / 40 */
    Perm22(.05635083268962916)
};
QUAD QUAD_3D_P5_ = {
    "3D P5",			/* name */
    3,				/* dim */
    5,				/* order */
    15,				/* npoints */
    QUAD_3D_P5_pts,		/* points */
    QUAD_3D_P5_wts,		/* weights */
    -1				/* id */
};
#else
static FLOAT QUAD_3D_P5_wts[] = {
    Dup31(.11268792571801585079918565233328633),
    Dup31(.07349304311636194954371020548632750),
    Dup22(.04254602077708146643806942812025744)

};
static FLOAT QUAD_3D_P5_pts[Length(QUAD_3D_P5_wts) * 4] = {
    Perm31(.31088591926330060979734573376345783),
    Perm31(.09273525031089122640232391373703061),
    Perm22(.04550370412564964949188052627933943)
};
QUAD QUAD_3D_P5_ = {
    "3D P5",			/* name */
    3,				/* dim */
    5,				/* order */
    Length(QUAD_3D_P5_wts),	/* npoints = 14 */
    QUAD_3D_P5_pts,		/* points */
    QUAD_3D_P5_wts,		/* weights */
    -1				/* id */
};
#endif

static FLOAT QUAD_3D_P6_wts[] = {
    Dup31(.03992275025816749209969062755747998),
    Dup31(.01007721105532064294801323744593686),
    Dup31(.05535718154365472209515327785372602),
    Dup211(27./560.)
};
static FLOAT QUAD_3D_P6_pts[Length(QUAD_3D_P6_wts) * 4] = {
    Perm31(.21460287125915202928883921938628499),
    Perm31(.04067395853461135311557944895641006),
    Perm31(.32233789014227551034399447076249213),
    /* (3 - sqrt(5)) / 12, (5 + sqrt(5)) / 12, (1 + sqrt(5)) / 12 */
    Perm211(.06366100187501752529923552760572698,
	    .60300566479164914136743113906093969)
};
QUAD QUAD_3D_P6_ = {
    "3D P6",			/* name */
    3,				/* dim */
    6,				/* order */
    Length(QUAD_3D_P6_wts),	/* npoints = 24 */
    QUAD_3D_P6_pts,		/* points */
    QUAD_3D_P6_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_3D_P7_wts[] = {
    Dup4(.09548528946413084886057843611722638),
    Dup31(.04232958120996702907628617079854674),
    Dup22(.03189692783285757993427482408294246),
    Dup211(.03720713072833462136961556119148112),
    Dup211(.00811077082990334156610343349109654)
};
static FLOAT QUAD_3D_P7_pts[Length(QUAD_3D_P7_wts) * 4] = {
    Perm4(.25),
    Perm31(.31570114977820279942342999959331149),
    Perm22(.05048982259839636876305382298656247),
    Perm211(.18883383102600104773643110385458576,
	    .57517163758700002348324157702230752),
    Perm211(.02126547254148324598883610149981994,
	    .81083024109854856111810537984823239)
};
QUAD QUAD_3D_P7_ = {
    "3D P7",                    /* name */
    3,                          /* dim */
    7,                          /* order */
    Length(QUAD_3D_P7_wts),     /* npoints = 35 */
    QUAD_3D_P7_pts,             /* points */
    QUAD_3D_P7_wts,             /* weights */
    -1                          /* id */
};

static FLOAT QUAD_3D_P8_wts[] = {
    Dup31(.00639714777990232132145142033517302),
    Dup31(.04019044802096617248816115847981783),
    Dup31(.02430797550477032117486910877192260),
    Dup31(.05485889241369744046692412399039144),
    Dup22(.03571961223409918246495096899661762),
    Dup211(.00718319069785253940945110521980376),
    Dup211(.01637218194531911754093813975611913)
};
static FLOAT QUAD_3D_P8_pts[Length(QUAD_3D_P8_wts) * 4] = {
    Perm31(.03967542307038990126507132953938949),
    Perm31(.31448780069809631378416056269714830),
    Perm31(.10198669306270330000000000000000000),
    Perm31(.18420369694919151227594641734890918),
    Perm22(.06343628775453989240514123870189827),
    Perm211(.02169016206772800480266248262493018,
	    .71993192203946593588943495335273478),
    Perm211(.20448008063679571424133557487274534,
	    .58057719012880922417539817139062041)
};
QUAD QUAD_3D_P8_ = {
    "3D P8",			/* name */
    3,				/* dim */
    8,				/* order */
    Length(QUAD_3D_P8_wts),	/* npoints = 46 */
    QUAD_3D_P8_pts,		/* points */
    QUAD_3D_P8_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_3D_P9_wts[] = {
    Dup4(.05642669317950620658871504327612541),
    Dup31(.00334109507471348040299974430471765),
    Dup31(.03011375476877376390731423843157491),
    Dup31(.00649096092006153463576211689456861),
    Dup211(.00980928586825458643196874259255500),
    Dup211(.02811915382336547255163261742529262),
    Dup211(.00789458690833150076834149200960885),
    Dup211(.01949281204723999671697219448924602)
};
static FLOAT QUAD_3D_P9_pts[Length(QUAD_3D_P9_wts) * 4] = {
    Perm4(.25),
    Perm31(.03402217700104486646540370887876764),
    Perm31(.32277033353380052539137668325496398),
    Perm31(.06045707742577493000000000000000000),
    Perm211(.45536299094720821180030815044164301,
	    .00568317736533017990610016014574474),
    Perm211(.11950225539382580097797370469611438,
	    .46311683247848994097622449365772955),
    Perm211(.02802195578340115815505750665412373,
	    .72520607683986748873856595428480993),
    Perm211(.17483303201157461578532464597224522,
	    .61668257178125640457068309097954073)
};
QUAD QUAD_3D_P9_ = {
    "3D P9",			/* name */
    3,				/* dim */
    9,				/* order */
    Length(QUAD_3D_P9_wts),	/* npoints = 61 */
    QUAD_3D_P9_pts,		/* points */
    QUAD_3D_P9_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_3D_P10_wts[] = {
    Dup4(.04739977355602073838473882117805110),
    Dup31(.02693705999226869980276416100488208),
    Dup31(.00986915971679338323455773543017308),
    Dup211(.00036194434433925362423987838480851),
    Dup211(.01013587167975579278851647011501678),
    Dup211(.01139388122019523162362093488071434),
    Dup211(.00657614727703590416745574020045070),
    Dup211(.02573973198045607127903601225965471),
    Dup211(.01290703579886199063929543024949899)
};
static FLOAT QUAD_3D_P10_pts[Length(QUAD_3D_P10_wts) * 4] = {
    Perm4(.25),
    Perm31(.31225006869518864772980831868682746),
    Perm31(.11430965385734615058737119765365045),
    Perm211(.00613800882479074784759371324841535,
	    .94298876734520486619763058691825076),
    Perm211(.03277946821644267077472102033232419,
	    .34018479408710763278898792494967132),
    Perm211(.41043073921896549428789784425151169,
	    .16548602561961105160449012444452641),
    Perm211(.03248528156482304783551493997842620,
	    .13385215221200951309782843596456662),
    Perm211(.12105018114558942599389500159505053,
	    .47719037990428035054410640829690722),
    Perm211(.17497934218393902428494922652831040,
	    .62807184547536601069327607221790967)
};
QUAD QUAD_3D_P10_ = {
    "3D P10",			/* name */
    3,				/* dim */
    10,				/* order */
    Length(QUAD_3D_P10_wts),	/* npoints = 81 */
    QUAD_3D_P10_pts,		/* points */
    QUAD_3D_P10_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_3D_P11_wts[] = {
    Dup4(.03943210802865886350733033449120443),
    Dup31(.01566212622727911315008856276876506),
    Dup31(.00333217237490140814440923615401491),
    Dup31(.01402607740748974743749136099769235),
    Dup211(.00108590752933246630682209837723547),
    Dup211(.02023596043066317891111657316540838),
    Dup211(.01179021487212586353684938046770181),
    Dup211(.00769031498252129590113157802073890),
    Dup211(.00443730570345920390473072602143959),
    Dup211(.01142954846718404041077055259859402),
    Dup1111(.00618564017121781141281925508389534)
};
static FLOAT QUAD_3D_P11_pts[Length(QUAD_3D_P11_wts) * 4] = {
    Perm4(.25),
    Perm31(.12149136777653379449770230990807224),
    Perm31(.03231625915107289635395445208958103),
    Perm31(.32492614978860679781284190241442197),
    Perm211(.00414835697166001200000000000001000,
	    .59826599679018635020545384277617780),
    Perm211(.22462461067637714141447515116498644,
	    .47366228783234957140836966920205236),
    Perm211(.05190508777256569674422721644265892,
	    .56314477790827989873710197630305713),
    Perm211(.13493013121624020422375917234299303,
	    .70835883078581895385699500512712996),
    Perm211(.02519119210825247292005118506530550,
	    .78371950734007737543057403429990901),
    Perm211(.36531877978173361396933198009886720,
	    .13460390831686580000000000000001000),
    Perm1111(.52290753950993847296521692758602923,
	     .14075363054369590184253913949127849,
	     .00976243819645261550829228038997777)
};
QUAD QUAD_3D_P11_ = {
    "3D P11",			/* name */
    3,				/* dim */
    11,				/* order */
    Length(QUAD_3D_P11_wts),	/* npoints = 109 */
    QUAD_3D_P11_pts,		/* points */
    QUAD_3D_P11_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_3D_P12_wts[] = {
    Dup31(.01276763770097074150203778596512505),
    Dup31(.01612110423790926821858154489575762),
    Dup31(.00037161269857844220004255818986081),
    Dup31(.01971744178668545763955330903818868),
    Dup31(.00257139093086271836218234759448548),
    Dup22(.00381724787051057590575318412783326),
    Dup22(.01208722707766311317860318419314605),
    Dup211(.00310586115843473343431688149929620),
    Dup211(.00545953133647103066912742126769441),
    Dup211(.00214289974849699750666852093655947),
    Dup211(.00552467146725782962244930098165075),
    Dup211(.00853695669449918042985177836672201),
    Dup1111(.01151017784832330697333644123403294),
    Dup1111(.00520387865288561360396792421252454)
};
static FLOAT QUAD_3D_P12_pts[Length(QUAD_3D_P12_wts) * 4] = {
    Perm31(.11529974435148014530455720738915911),
    Perm31(.20233628224059090000000000000001000),
    Perm31(.01171759795761995151247906754831398),
    Perm31(.31330644136780106727760279964458934),
    Perm31(.25000573011558370000000000000001000),
    Perm22(.02099547435075800669020182527059018),
    Perm22(.15177401824745010000000000000001000),
    Perm211(.02441977874343536478314000904761661,
	    .84832928469787285064520886743481574),
    Perm211(.25620709853201830896382010708562210,
	    .48248737387384884780289289672973542),
    Perm211(.01679032097960299061471796028857942,
	    .69477194236575592695949850988417719),
    Perm211(.12616082113987204239970703846895919,
	    .72541048930294811897485950521263380),
    Perm211(.43143517452637984721670695066371957,
	    .11272193989285241520959977211007542),
    Perm1111(.50167006246250569747515507168476130,
	     .27247180286952239178351046753060445,
	     .07207432880729891465015948456335820),
    Perm1111(.26164485453781874566945505006396799,
	     .08629229194706173191742351944352488,
	     .02056541065587613830062489762710900)
};
QUAD QUAD_3D_P12_ = {
    "3D P12",			/* name */
    3,				/* dim */
    12,				/* order */
    Length(QUAD_3D_P12_wts),	/* npoints = 140 */
    QUAD_3D_P12_pts,		/* points */
    QUAD_3D_P12_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_3D_P13_wts[] = {
    Dup4(.01501368777308314675062970631615983),
    Dup31(.01822520928017342532379068941490097),
    Dup31(.00700610921774146424038518693926311),
    Dup22(.01642354974394954829540573107905531),
    Dup22(.00512061009636059707262596949702171),
    Dup22(.01119669865290491634382032086351956),
    Dup211(.01561914973337995400953811302431969),
    Dup211(.00248442301331647441904056776338473),
    Dup211(.00163859853481823893844525309440751),
    Dup211(.00590303044012492197171914655535865),
    Dup211(.01102208245821805240445097989201525),
    Dup211(.00040645183996417822585155512755848),
    Dup1111(.00268796997296854209745781926651729),
    Dup1111(.00197950480552671190531894675510740),
    Dup1111(.00544631918142579120943187040108667)
};
static FLOAT QUAD_3D_P13_pts[Length(QUAD_3D_P13_wts) * 4] = {
    Perm4(.25),
    Perm31(.15521609351908950314115784335704739),
    Perm31(.33012266333967360024433192595196779),
    Perm22(.16680640389386249928937782601144234),
    Perm22(.02492378854777361779701400374860089),
    Perm22(.09719762991575100143072243716240818),
    Perm211(.24785929015736256692746910620827934,
	    .43365324235685144718726061434767377),
    Perm211(.02223159608186700290879521860892929,
	    .83690032040373400514509486595698594),
    Perm211(.10727869331305341049150459639584801,
	    .77498030597500180756587877274179289),
    Perm211(.19817684388398981142331840582142759,
	    .58756930578220530259172017903595920),
    Perm211(.06917924347737931647732534347465502,
	    .60420006666006644707935264871115302),
    Perm211(.02311471947193316000000000000001000,
	    .93087579279244424864920228882888307),
    Perm1111(.11788928751019608922290117470644250,
	     .11651536422540720000000000000001000,
	     .04202400112551542095676634303719997),
    Perm1111(.67703279860228426355032221326746594,
	     .04616537602461971083458041122176081,
	     .00084434031890503975729899692135905),
    Perm1111(.48489008867363312201080094154790828,
	     .35888294295520201572423646909421086,
	     .13818283491762872996955080907912355)
};
QUAD QUAD_3D_P13_ = {
    "3D P13",			/* name */
    3,				/* dim */
    13,				/* order */
    Length(QUAD_3D_P13_wts),	/* npoints = 171 */
    QUAD_3D_P13_pts,		/* points */
    QUAD_3D_P13_wts,		/* weights */
    -1				/* id */
};

static FLOAT QUAD_3D_P14_wts[] = {
    Dup31(.00406511366527076704362088368356360),
    Dup31(.00221453853344557814375995695000715),
    Dup31(.00581343826788845054953733388214554),
    Dup31(.01962554338583572159756233339617148),
    Dup31(.00038757379059082143645387212483937),
    Dup211(.01164297197217703698552134010055516),
    Dup211(.00528904298828171313177368830528561),
    Dup211(.00183108541636005593766978234880692),
    Dup211(.00824964737721464520674496691736603),
    Dup1111(.00300992453470824513768887482089866),
    Dup1111(.00080471656173675346362618087603116),
    Dup1111(.00298504125884930711876556928839215),
    Dup1111(.00568960024187607669633614778119730),
    Dup1111(.00415908658785457156700139801826135),
    Dup1111(.00072823892045727243561364297456536),
    Dup1111(.00543265007699582482162423406519264)
};
static FLOAT QUAD_3D_P14_pts[Length(QUAD_3D_P14_wts) * 4] = {
    Perm31(.32725336252384856390930966926852893),
    Perm31(.04476130446668508088379420964788419),
    Perm31(.08614033110243635365372087402988575),
    Perm31(.20876264250043229682653570839761758),
    Perm31(.01410497380292096006358791521029282),
    Perm211(.10216532418077681234766925269825839,
	    .57394636759433382028140028934601068),
    Perm211(.40757005166001071572132956513017833,
	    .09222787013902013000000000000000000),
    Perm211(.01566400074028035855575867095780840,
	    .70128109595894403271399676732084261),
    Perm211(.22549635625250290537807241542011034,
	    .47690639744208871158605833541070112),
    Perm1111(.39059842812814580000000000000000000,
	     .20135905441239221681230773272350923,
	     .01611228807103002985780269315483708),
    Perm1111(.10613506799890214555561390298480794,
	     .03273581868172692849440040779126601,
	     .00359790765372716669079715233859245),
    Perm1111(.56363837316977438968968166306485017,
	     .23029207223006574545025268741356515,
	     .19071993417435518627124877906378985),
    Perm1111(.36762550953258608440922067759911669,
	     .20788513802300449507171021252507348,
	     .33121048851934490000000000000000000),
    Perm1111(.71923236898172952950234018407969909,
	     .17632791180193297621579930336369727,
	     .02076023625713100907549734406116442),
    Perm1111(.52782499521529872984092400758172763,
	     .43728908922034181655262387608419181,
	     .00922016518566419494631775549492202),
    Perm1111(.54836745449481907289949105056077457,
	     .34478155061716412287036718709203314,
	     .08672172833222153946294387400858277)
};
QUAD QUAD_3D_P14_ = {
    "3D P14",			/* name */
    3,				/* dim */
    14,				/* order */
    Length(QUAD_3D_P14_wts),	/* npoints = 236 */
    QUAD_3D_P14_pts,		/* points */
    QUAD_3D_P14_wts,		/* weights */
    -1				/* id */
};

/*------------------ functions computing order of a basis -------------------*/

//#if 1
//# define BasisOrder(u, e, i) (!DofIsHP(u) ? (u)->type->order : \
//	(u)->hp->info->types[(u)->hp->elem_order[e->index]]->order)
//#else	/* 0|1 */
//# define BasisOrder(u, e, i) basis_order(u, e, i)
//
//static inline int
//basis_order(DOF *u, SIMPLEX *e, int ibas)
//{
//    DOF_TYPE *type;
//    HP_TYPE *hp;
//    BYTE *orders;
//    GTYPE gtype;
//    int n, m, gind, bind;
//
//    if ((type = u->type) != NULL) {
//	/* non h-p DOF */
//	if (type->base_type != NULL)
//	    type = type->base_type;
//	if ((orders = type->orders) == NULL || ibas < 0 || ibas >= type->nbas)
//	    return type->order;
//	if (ibas < (n = NVert * type->np_vert))
//	    return orders[ibas % type->np_vert];
//	orders += type->np_vert;
//	if ((ibas -= n) < (m = NEdge * type->np_edge))
//	    return orders[ibas % type->np_edge];
//	orders += type->np_edge;
//	if ((ibas -= m) < (n = NFace * type->np_face))
//	    return orders[ibas % type->np_face];
//	return orders[type->np_face + ibas - n];
//    }
//
//    /* h-p DOF */
//    hp = u->hp;
//    phgDofGetElementBasisInfo(u, e, ibas, &gtype, &gind, &bind);
//    switch (gtype) {
//	case VERTEX:
//	    break;
//	case EDGE:
//	    type = hp->info->types[hp->edge_order[e->edges[gind]]];
//	    if (type->base_type != NULL)
//		type = type->base_type;
//	    if ((orders = type->orders) == NULL)
//		return type->order;
//	    return orders[type->np_vert + bind];
//	case FACE:
//	    type = hp->info->types[hp->face_order[e->faces[gind]]];
//	    if (type->base_type != NULL)
//		type = type->base_type;
//	    if ((orders = type->orders) == NULL)
//		return type->order;
//	    return orders[type->np_vert + type->np_edge + bind];
//	case ELEMENT:
//	    type = hp->info->types[hp->elem_order[e->index]];
//	    if (type->base_type != NULL)
//		type = type->base_type;
//	    if ((orders = type->orders) == NULL)
//		return type->order;
//	    return orders[type->np_vert + type->np_edge + type->np_face + bind];
//	default:
//	    phgError(1, "unexpected error.\n");
//    }
//
//    return 0;	/* make gcc happy */
//}
//#endif	/* 0|1 */
//
//
///*---------------- functions managing caches and quad_list ------------------*/
//
//static QUAD **quad_list = NULL;
//static size_t quad_list_count = 0, quad_list_allocated = 0;
//
//#if 0
//static inline QUAD_CACHE *
//#else
//static QUAD_CACHE *
//#endif
//get_cache(void **clist_ptr, QUAD *quad)
///* returns the cache in '**clist' matching 'quad' */
//{
//    QUAD_CACHE_LIST *clist;
//    QUAD_CACHE *cache;
//
//    if (quad->id < 0) {
//#if USE_OMP
//#pragma omp critical (get_cache1)
//      if (quad->id < 0) {
//#endif	/* USE_OMP */
//	/* assign an id to quad */
//	if (quad_list_count >= quad_list_allocated) {
//	    quad_list = phgRealloc_(quad_list,
//				(quad_list_allocated + 8) * sizeof(*quad_list),
//				quad_list_allocated * sizeof(*quad_list));
//	    quad_list_allocated += 8;
//	}
//	quad_list[quad_list_count] = quad;
//	quad_list_count++;
//	quad->id = quad_list_count - 1;
//#if USE_OMP
//      }
//#endif	/* USE_OMP */
//    }
//
//    assert(quad->id < quad_list_count && quad_list[quad->id] == quad);
//
//    if ((clist = *clist_ptr) == NULL) {
//#if USE_OMP
//#pragma omp critical (get_cache2)
//      if ((clist = *clist_ptr) == NULL)
//#endif	/* USE_OMP */
//	*clist_ptr = clist = phgCalloc(phgMaxThreads, sizeof(*clist));
//    }
//    clist += phgThreadId;
//
//    if (clist->n <= quad->id) {
//	/* expand the list to quad->id + 1 entries */
//	clist->caches = phgRealloc_(clist->caches,
//				   (quad->id + 1) * sizeof(*cache),
//				   clist->n * sizeof(*cache));
//	while (clist->n <= quad->id)
//	    clist->caches[clist->n++] = NULL;
//    }
//
//    if ((cache = clist->caches[quad->id]) == NULL) {
//	cache = clist->caches[quad->id] = phgAlloc(sizeof(*cache));
//	cache->e = NULL;
//	cache->data = NULL;
//    }
//
//    return cache;
//}
//
//void
//phgQuadReset(void)
//{
//    int i;
//
//    /* Free quad_list entries */
//    for (i = 0; i < quad_list_count; i++) {
//	quad_list[i]->id = -1;
//    }
//    phgFree(quad_list);
//    quad_list = NULL;
//    quad_list_count = quad_list_allocated = 0;
//
//    /* The calls below will free dynamically generated quadrature rules */
//    phgQuadGetQuad1D(-1);
//    phgQuadGetQuad2D(-1);
//    phgQuadGetQuad3D(-1);
//}
//
//void
//phgQuadClearDofCache(void **clist0, QUAD *quad, BOOLEAN final)
///* clear one or all cached DOF (basis) values in clist */
//{
//    QUAD_CACHE_LIST **clist, *pl;
//    int i, n;
//
//    if (quad == NULL)
//	phgQuadGetFuncValues(NULL, NULL, 0, NULL, NULL);
//
//    if (*(clist = (QUAD_CACHE_LIST **)clist0) == NULL ||
//	(quad != NULL && quad->id == -1))
//	return;
//
//#if USE_OMP
//    for (pl = *clist; pl < *clist + phgMaxThreads; pl++) {
//#else	/* USE_OMP */
//    pl = *clist;
//#endif	/* USE_OMP */
//
//    /* clear cache for 'quad' */
//    if (quad != NULL) {
//	i = quad->id;
//	assert(i < quad_list_count && quad_list[i] == quad);
//	n = i + 1;
//    }
//    else {
//	i = 0;
//	n = pl->n;
//    }
//
//    for (; i < n; i++) {
//	if (pl->caches[i] == NULL)
//	    continue;
//	pl->caches[i]->e = NULL;
//	phgFree(pl->caches[i]->data);
//	pl->caches[i]->data = NULL;
//	if (final) {
//	    phgFree(pl->caches[i]);
//	    pl->caches[i] = NULL;
//	}
//    }
//
//    if (quad == NULL && final)
//	phgFree(pl->caches);
//
//#if USE_OMP
//    }
//#endif	/* USE_OMP */
//
//    if (quad == NULL && final) {
//	phgFree(*clist);
//	*clist = NULL;
//    }
//}
//
///*----------------- Basis and userfunc caching utilities -------------------*/
//
//const FLOAT *
//phgQuadGetFuncValues(GRID *g, SIMPLEX *e, int dim, DOF_USER_FUNC userfunc,
//		     QUAD *quad)
///* cache and returns the function values of 'userfunc' at quadrature points of
// * 'quad'. if quad == NULL then clear cached values */
//{
//    static FLOAT *funcvalues = NULL;
//    static QUAD *cached_quad = NULL;
//    static SIMPLEX *cached_e = NULL;
//    static INT cached_serial_no = -1;
//    static DOF_USER_FUNC cached_userfunc = NULL;
//
//    int i;
//    FLOAT *v;
//    const FLOAT *lambda;
//    FLOAT x, y, z;
//
//    CheckThread
//
//    if (quad == NULL) {
//	/* clear cache */
//	phgFree(funcvalues);
//	funcvalues = NULL;
//	cached_quad = NULL;
//	cached_e = NULL;
//	cached_serial_no = -1;
//	cached_userfunc = NULL;
//	return NULL;
//    }
//
//    if (cached_quad != quad || cached_e != e || cached_userfunc != userfunc
//	|| cached_serial_no != g->serial_no) {
//	cached_quad = quad;
//	cached_e = e;
//	cached_serial_no = g->serial_no;
//	cached_userfunc = userfunc;
//
//	/* compute function values */
//	lambda = quad->points;
//	phgFree(funcvalues);
//	funcvalues = phgAlloc(dim * quad->npoints * sizeof(*funcvalues));
//	for (i = 0, v = funcvalues; i < quad->npoints; i++, v += dim) {
//	    phgGeomLambda2XYZ(g, e, lambda, &x, &y, &z);
//	    userfunc(x, y, z, v);
//	    lambda += Dim + 1;
//	}
//    }
//
//    return funcvalues;
//}
//
//const FLOAT *
//phgQuadGetBasisValues(SIMPLEX *e, DOF *u, int n, QUAD *quad)
///* returns the address of an array containing the values of the n-th
// * basis function at the quadrature points of 'quad'. The values are
// * returned in the order FLOAT[quad->npoints][type->dim]
// *
// * Note: in the internal buffer the values are stored as:
// *	FLOAT[nbas][quad->npoints][type->dim]
// */
//{
//    DOF_TYPE *type;
//    QUAD_CACHE *cache;
//    const FLOAT *v, *lambda;
//    FLOAT *bas;
//    int i, j, nbas;
//
//    assert(!SpecialDofType(u->type));
//
//    if (!DofIsHP(u)) {
//	type = u->type;
//	nbas = type->nbas;
//	cache = get_cache(&type->cache_basfunc, quad);
//    }
//    else {
//	type = u->hp->info->types[u->hp->max_order];
//	nbas = DofGetNBas(u, e);
//	cache = get_cache(&u->hp->cache_basfunc, quad);
//    }
//
//    if (cache->data != NULL &&
//	((!DofIsHP(u) && type->invariant) || cache->e == e))
//	return cache->data + n * quad->npoints * type->dim;
//
//    if (type->BasFuncs == NULL)
//	phgError(1, "no basis function for DOF \"%s\"!\n", u->name);
//
//    cache->e = e;
//    phgFree(cache->data);
//    bas = cache->data =
//		phgAlloc(nbas * quad->npoints * type->dim * sizeof(*bas));
//    lambda = quad->points;
//    for (i = 0; i < quad->npoints; i++) {
//	v = type->BasFuncs(u, e, 0, -1, lambda);
//	bas = cache->data + i * type->dim;
//	for (j = 0; j < nbas; j++) {
//	    memcpy(bas, v, type->dim * sizeof(*v));
//	    v += type->dim;
//	    bas += quad->npoints * type->dim;
//	}
//	lambda += Dim + 1;
//    }
//
//    return cache->data + n * quad->npoints * type->dim;
//}
//
//static inline const FLOAT *
//get_grad_lambda(SIMPLEX *e, DOF *u, int n, QUAD *quad)
///* returns the address of an array containing the values of the lambda
// * gradient of the n-th basis function at the quadrature points of 'quad'.
// * The values are returned as:
// *	FLOAT[quad->npoints][type->dim][Dim + 1]
// *
// * Note: in the internal buffer the values are stored as:
// *	FLOAT[nbas][quad->npoints][type->dim][Dim + 1]
// */
//{
//    DOF_TYPE *type;
//    QUAD_CACHE *cache;
//    const FLOAT *v;
//    FLOAT *grad, *lambda;
//    int i, j, nbas, ngrad, nvalues;
//
//    assert(!SpecialDofType(u->type));
//
//    if (!DofIsHP(u)) {
//	type = u->type;
//	nbas = type->nbas;
//	cache = get_cache(&u->type->cache_basgrad, quad);
//    }
//    else {
//	type = u->hp->info->types[u->hp->max_order];
//	nbas = DofGetNBas(u, e);
//	cache = get_cache(&u->hp->cache_basgrad, quad);
//    }
//    ngrad = nbas * type->dim;
//
//    if (cache->data != NULL &&
//	((!DofIsHP(u) && type->invariant) || cache->e == e))
//	return cache->data + n * quad->npoints * type->dim * (Dim + 1);
//
//    if (type->BasGrads == NULL)
//	phgError(1, "no gradient function for DOF \"%s\"!\n", u->name);
//
//    cache->e = e;
//    phgFree(cache->data);
//    cache->data = phgAlloc(quad->npoints * ngrad * (Dim + 1) * sizeof(*grad));
//    lambda = quad->points;
//    nvalues = (Dim + 1) * type->dim;
//    for (i = 0; i < quad->npoints; i++) {
//	v = type->BasGrads(u, e, 0, -1, lambda);
//	grad = cache->data + i * nvalues;
//	for (j = 0; j < nbas; j++) {
//	    memcpy(grad, v, nvalues * sizeof(*v));
//	    v += nvalues;
//	    grad += quad->npoints * nvalues;
//	}
//	lambda += Dim + 1;
//    }
//
//    return cache->data + n * quad->npoints * type->dim * (Dim + 1);
//}
//
//const FLOAT *
//phgQuadGetBasisGradient(SIMPLEX *e, DOF *u, int n, QUAD *quad)
///* returns the xyz gradients of the n-th basis function on element e
// * The values are returned as
// *	FLOAT[quad->npoints][type->dim][Dim]
// *
// * Note: in the internal buffer the values are stored as:
// *	FLOAT[nbas][quad->npoints][type->dim][Dim]
// */
//{
//    DOF_TYPE *type;
//    QUAD_CACHE *cache;
//    int i, j, k;
//    int nbas, nvalues, npoints = quad->npoints;
//    FLOAT *data, *p;
//    const FLOAT *J, *J1, *G;
//
//    assert(!SpecialDofType(u->type));
//
//    if (!DofIsHP(u)) {
//	type = u->type;
//	nbas = type->nbas;
//	cache = get_cache(&u->type->cache_gradient, quad);
//    }
//    else {
//	type = u->hp->info->types[u->hp->max_order];
//	nbas = DofGetNBas(u, e);
//	cache = get_cache(&u->hp->cache_gradient, quad);
//    }
//    nvalues = Dim * type->dim;
//
//    if (cache->data != NULL && cache->e == e)
//	return cache->data + n * npoints * nvalues;
//
//    cache->e = e;
//    phgFree(cache->data);
//    data = cache->data = phgAlloc(nbas * npoints * nvalues * sizeof(*data));
//
//    J = phgGeomGetJacobian(u->g, e);
//    for (k = 0; k < nbas; k++, data += npoints * nvalues) {
//	if (k < NVert && !DofIsHP(u) && type->name[0] == 'P'
//	    && type->name[1] >= '0' && type->name[1] <= '9') {
//	    /* faster code for special case */
//	    p = data;
//	    if (type == DOF_P0) {
//		npoints *= Dim;
//		for (i = 0; i < npoints; i++) {
//		    *(p++) = 0.;
//		}
//	    }
//	    else if (type == DOF_P1) {
//		/* D\phi / D\lambda is the unit matrix */
//		J1 = J + k * (Dim + 1);
//		for (i = 0; i < npoints; i++) {
//		    memcpy(p, J1, Dim * sizeof(*data));
//		    p += Dim;
//		}
//	    }
//	    else {
//		/* the first NVert rows of D\phi / D\lambda are diagonal */
//		G = get_grad_lambda(e, u, k, quad) + k;
//		J1 = J + k * (Dim + 1);
//		for (i = 0; i < npoints; i++) {
//		    FLOAT d = *G;
//		    *(p++) = d * J1[0];
//		    *(p++) = d * J1[1];
//		    *(p++) = d * J1[2];
//		    G += Dim + 1;
//		}
//	    }
//	}
//	else {
//	    G = get_grad_lambda(e, u, k, quad);
//	    /* compute data[npoints][Dim] = G[npoints][Dim+1] * J[Dim+1][Dim] */
//#if 0
//	    if (npoints > 4) {
//		static FLOAT a = 1.0, b = 0.0;
//		int k = (Dim + 1) * type->dim, j = Dim * type->dim;
//		F77name(dgemm) ("t", "t", &npoints, &j, &k, &a, G, &k, J, &k,
//				&b, data, &k);
//		return data;
//	    }
//#else
//	    p = data;
//	    for (i = 0; i < npoints; i++) {
//		for (j = 0; j < type->dim; j++) {
//		    *(p++) = G[0] * J[0 * (Dim + 1) + 0] +
//			G[1] * J[1 * (Dim + 1) + 0] +
//			G[2] * J[2 * (Dim + 1) + 0] +
//			G[3] * J[3 * (Dim + 1) + 0];
//		    *(p++) = G[0] * J[0 * (Dim + 1) + 1] +
//			G[1] * J[1 * (Dim + 1) + 1] +
//			G[2] * J[2 * (Dim + 1) + 1] +
//			G[3] * J[3 * (Dim + 1) + 1];
//		    *(p++) = G[0] * J[0 * (Dim + 1) + 2] +
//			G[1] * J[1 * (Dim + 1) + 2] +
//			G[2] * J[2 * (Dim + 1) + 2] +
//			G[3] * J[3 * (Dim + 1) + 2];
//		    G += Dim + 1;
//		}
//	    }
//#endif
//	}
//    }
//
//    return cache->data + n * npoints * nvalues;
//}
//
//const FLOAT *
//phgQuadGetBasisCurl(SIMPLEX *e, DOF *u, int n, QUAD *quad)
///* returns the curl of the n-th basis functions at quadrature points
// * the values are cached as FLOAT[nbas][quad->npoints][type->dim]
// * The requested values are returned as
// *	FLOAT[quad->npoints][type->dim]
// * (type->dim % Dim == 0)
// */
//{
//    DOF_TYPE *type;
//    QUAD_CACHE *cache;
//    FLOAT *curl;
//    int i, j, nbas;
//    int I, J;
//
//    assert(!SpecialDofType(u->type));
//
//    if (!DofIsHP(u)) {
//	type = u->type;
//	nbas = type->nbas;
//	cache = get_cache(&u->type->cache_curl, quad);
//    }
//    else {
//	type = u->hp->info->types[u->hp->max_order];
//	nbas = DofGetNBas(u, e);
//	cache = get_cache(&u->hp->cache_curl, quad);
//    }
//
//    if (type->dim % Dim != 0)
//	phgError(1, "%s:%d, cannot compute curl of \"%s\" whose dimension is "
//		 "not multiple of %d\n", u->name, Dim);
//
//    if (cache->data != NULL && cache->e == e)
//	return cache->data + n * quad->npoints * type->dim;
//
//    cache->e = e;
//    phgFree(cache->data);
//    cache->data =
//	phgAlloc(nbas * quad->npoints * type->dim * sizeof(*curl));
//
//    if (!DofIsHP(u) && type == DOF_ND1) {
//	/* faster code (?) for Nedelec-1 element */
//	FLOAT (*nabla)[Dim + 1] = (void *)(phgGeomGetJacobian(u->g, e));
//	for (i = 0; i < quad->npoints; i++) {
//	    curl = cache->data + i * type->dim;
//	    for (j = 0; j < nbas; j++) {
//		GetEdgeVertices(e, j, I, J);
//		curl[0] =
//		    (nabla[I][1] * nabla[J][2] -
//		     nabla[I][2] * nabla[J][1]) * 2.;
//		curl[1] =
//		    (nabla[I][2] * nabla[J][0] -
//		     nabla[I][0] * nabla[J][2]) * 2.;
//		curl[2] =
//		    (nabla[I][0] * nabla[J][1] -
//		     nabla[I][1] * nabla[J][0]) * 2.;
//		curl += quad->npoints * type->dim;
//	    }
//	}
//    }
//    else {
//	FLOAT (*g)[Dim];
//	for (i = 0; i < quad->npoints; i++) {
//	    curl = cache->data + i * type->dim;
//	    for (j = 0; j < nbas; j++) {
//		g = (void *)(phgQuadGetBasisGradient(e, u, j, quad) +
//			     i * type->dim * Dim);
//		curl[0] = g[2][1] - g[1][2];
//		curl[1] = g[0][2] - g[2][0];
//		curl[2] = g[1][0] - g[0][1];
//		curl += quad->npoints * type->dim;
//	    }
//	}
//    }
//
//    return cache->data + n * quad->npoints * type->dim;
//}
//
//const FLOAT *
//phgQuadGetDofValues(SIMPLEX *e, DOF *u, QUAD *quad)
///* returns the address of an array containing the values of dof
// * at the quadrature points of 'quad', the values are stored in the order
// * FLOAT[quad->npoints][DofDim(u)].
// */
//{
//    QUAD_CACHE *cache;
//    FLOAT *v;
//    const FLOAT *bas, *lambda;
//    int nvalues = DofDim(u);
//    int i;
//
//    cache = get_cache(&u->cache_func, quad);
//    if (cache->data != NULL && (u->invariant || cache->e == e))
//	return cache->data;
//
//    cache->e = e;
//    phgFree(cache->data);
//    v = cache->data = phgAlloc(quad->npoints * nvalues * sizeof(*v));
//    /* Note: calling phgQuadGetBasisValues may further save recomputation
//     * of basis functions if u->type->invariant == TRUE (or when computing
//     * u dot u). By requesting values for basis function 0 we eventually
//     * get the start address of values of all basis functions at the
//     * quadrature points, stored as
//     *          FLOAT[nbas][quad->npoints][type->dim]
//     */
//    if (!SpecialDofType(u->type) && !DofIsHP(u))
//	bas = phgQuadGetBasisValues(e, u, 0, quad);
//    else
//	bas = NULL;
//    lambda = quad->points;
//    for (i = 0; i < quad->npoints; i++) {
//	phgDofEval_(u, e, lambda, bas, quad->npoints * DofTypeDim(u), v, NULL);
//	v += nvalues;
//	if (bas != NULL)
//	    bas += u->type->dim;
//	lambda += Dim + 1;
//    }
//    return cache->data;
//}
//
///*------------------------------ 2D functions --------------------------------*/
//
//FLOAT
//phgQuadFaceDofDotBas(SIMPLEX *e, int face, DOF *u, DOF_PROJ proj,
//		     DOF *v, int N, int order)
//{
//    GRID *g = u->g;
//    int i, j, k, nvalues, v0, v1, v2, dim;
//    FLOAT d, d0, lambda[Dim + 1];
//    FLOAT *dof, *buffer, *p0, *p1;
//    const FLOAT *bas, *p, *w;
//    QUAD *quad;
//    const FLOAT *n = NULL;	/* out normal vector */
//    DOF_TYPE *type;
//
//    assert(!SpecialDofType(v->type));
//    assert(face >= 0 && face <= 3);
//
//    type = (DofIsHP(v) ? v->hp->info->types[v->hp->max_order] : v->type);
//
//    if (order < 0) {
//	i = DofTypeOrder(u, e);
//	j = DofTypeOrder(v, e);
//	if (i < 0)
//	    i = j;
//	order = i + j;
//    }
//    quad = phgQuadGetQuad2D(order);
//
//    v0 = GetFaceVertex(face, 0);
//    v1 = GetFaceVertex(face, 1);
//    v2 = GetFaceVertex(face, 2);
//    lambda[face] = 0.;
//
//    dim = DofDim(u) / (proj == DOF_PROJ_DOT ? Dim : 1);
//    nvalues = DofTypeDim(v);
//
//    if (nvalues != dim)
//	phgError(1, "%s: dimensions mismatch\n", __func__);
//
//    buffer = phgAlloc(nvalues * sizeof(*buffer));
//    p = quad->points;
//    w = quad->weights;
//
//    d = 0.;
//    switch (proj) {
//        case DOF_PROJ_NONE:
//             for (i = 0; i < quad->npoints; i++) {
//                 lambda[v0] = *(p++);
//                 lambda[v1] = *(p++);
//                 lambda[v2] = *(p++);
//
//		 dof = phgDofEval(u, e, lambda, buffer);
//                 bas = (FLOAT *)type->BasFuncs(v, e, N, N + 1, lambda);
//                 d0 = 0.;
//                 for (j = 0; j < nvalues; j++) {
//                     d0 += *(bas++) * *(dof++);
//		 }
//		 d += d0 * *(w++);
//	     }
//
//	     phgFree(buffer);
//             break;
//
//        case DOF_PROJ_DOT:
//             p0 = phgAlloc(nvalues * Dim * sizeof(*p0));
//	     n = phgGeomGetFaceOutNormal(g, e, face);
//             for (i = 0; i < quad->npoints; i++) {
//                 lambda[v0] = *(p++);
//                 lambda[v1] = *(p++);
//                 lambda[v2] = *(p++);
//
//		 p1 = phgDofEval(u, e, lambda, p0);
//                 bas = type->BasFuncs(v, e, N, N + 1, lambda);
//		 dof = buffer;
//		 for (k = 0; k < nvalues; k++) {
//                      *(dof++) = n[0] * p1[0] + n[1] * p1[1] + n[2] * p1[2];
//		      p1 += Dim;
//		 }
//                 d0 = 0.;
//		 dof = buffer;
//                 for (j = 0; j < nvalues; j++) {
//                     d0 += *(bas++) * *(dof++);
//		 }
//		 d += d0 * *(w++);
//	     }
//
//             phgFree(buffer);
//             phgFree(p0);
//             break;
//
//        case DOF_PROJ_CROSS:
//             p0 = phgAlloc(nvalues * sizeof(*p0));
//	     n = phgGeomGetFaceOutNormal(g, e, face);
//             for (i = 0; i < quad->npoints; i++) {
//                 lambda[v0] = *(p++);
//                 lambda[v1] = *(p++);
//                 lambda[v2] = *(p++);
//
//		 p1 = phgDofEval(u, e, lambda, p0);
//                 bas = type->BasFuncs(v, e, N, N + 1, lambda);
//		 dof = buffer;
//		 for (k = 0; k < nvalues / Dim; k++) {
//                      *(dof++) = p1[1] * n[2] - p1[2] * n[1];
//		      *(dof++) = p1[2] * n[0] - p1[0] * n[2];
//                      *(dof++) = p1[0] * n[1] - p1[1] * n[0];
//		      p1 += Dim;
//		 }
//                 d0 = 0.;
//		 dof = buffer;
//                 for (j = 0; j < nvalues; j++) {
//                     d0 += *(bas++) * *(dof++);
//		 }
//		 d += d0 * *(w++);
//	     }
//
//             phgFree(buffer);
//             phgFree(p0);
//             break;
//
//        default:
//             phgError(1, "%s: unknown projection %d\n", __func__, proj);
//    }
//
//    return d * phgGeomGetFaceArea(u->g, e, face);
//}
//
//FLOAT
//phgQuadFaceDofDotDof(SIMPLEX *e, int face, DOF *u, DOF_PROJ proj,
//		     DOF *v, int order)
//{
//    GRID *g = u->g;
//    int i, j, k, nvalues, v0, v1, v2, dim;
//    FLOAT d, d0, lambda[Dim + 1];
//    FLOAT *dof, *buffer, *p0, *p1;
//    FLOAT *dofv, *pv;
//    const FLOAT *p, *w;
//    QUAD *quad;
//    const FLOAT *n = NULL;	/* out normal vector */
//
//    assert(face >= 0 && face <= 3);
//
//    if (order < 0) {
//	i = DofTypeOrder(u, e);
//	j = DofTypeOrder(v, e);
//	if (i < 0)
//	    i = j;
//	order = i + j;
//    }
//    quad = phgQuadGetQuad2D(order);
//
//    v0 = GetFaceVertex(face, 0);
//    v1 = GetFaceVertex(face, 1);
//    v2 = GetFaceVertex(face, 2);
//    lambda[face] = 0.;
//
//    dim = DofDim(u) / (proj == DOF_PROJ_DOT ? Dim : 1);
//    nvalues = DofDim(v);
//
//    if (nvalues != dim)
//	phgError(1, "%s: dimensions mismatch\n", __func__);
//
//    buffer = phgAlloc(nvalues * sizeof(*buffer));
//    dofv = phgAlloc(nvalues * sizeof(*dofv));
//    p = quad->points;
//    w = quad->weights;
//
//    d = 0.;
//    switch (proj) {
//        case DOF_PROJ_NONE:
//             for (i = 0; i < quad->npoints; i++) {
//                 lambda[v0] = *(p++);
//                 lambda[v1] = *(p++);
//                 lambda[v2] = *(p++);
//
//		 dof = phgDofEval(u, e, lambda, buffer);
//                 pv = phgDofEval(v, e, lambda, dofv);
//                 d0 = 0.;
//                 for (j = 0; j < nvalues; j++) {
//                     d0 += *(pv++) * *(dof++);
//		 }
//		 d += d0 * *(w++);
//	     }
//
//             phgFree(buffer);
//	     phgFree(dofv);
//             break;
//
//        case DOF_PROJ_DOT:
//             p0 = phgAlloc(nvalues * Dim * sizeof(*p0));
//	     n = phgGeomGetFaceOutNormal(g, e, face);
//
//             for (i = 0; i < quad->npoints; i++) {
//                 lambda[v0] = *(p++);
//                 lambda[v1] = *(p++);
//                 lambda[v2] = *(p++);
//
//		 p1 = phgDofEval(u, e, lambda, p0);
//		 pv = phgDofEval(v, e, lambda, dofv);
//		 dof = buffer;
//		 for (k = 0; k < nvalues; k++) {
//                      *(dof++) = n[0] * p1[0] + n[1] * p1[1] + n[2] * p1[2];
//		      p1 += Dim;
//		 }
//
//                 d0 = 0.;
//		 dof = buffer;
//                 for (j = 0; j < nvalues; j++) {
//                     d0 += *(pv++) * *(dof++);
//		 }
//		 d += d0 * *(w++);
//	     }
//
//             phgFree(buffer);
//	     phgFree(dofv);
//             phgFree(p0);
//             break;
//
//        case DOF_PROJ_CROSS:
//	     assert(DofDim(u) % Dim == 0);
//             p0 = phgAlloc(nvalues * sizeof(*p0));
//	     n = phgGeomGetFaceOutNormal(g, e, face);
//
//	     for (i = 0; i < quad->npoints; i++) {
//                 lambda[v0] = *(p++);
//                 lambda[v1] = *(p++);
//                 lambda[v2] = *(p++);
//
//		 p1 = phgDofEval(u, e, lambda, p0);
//		 pv = phgDofEval(v, e, lambda, dofv);
//		 dof = buffer;
//		 for (k = 0; k < nvalues / Dim; k++) {
//                      *(dof++) = p1[1] * n[2] - p1[2] * n[1];
//		      *(dof++) = p1[2] * n[0] - p1[0] * n[2];
//                      *(dof++) = p1[0] * n[1] - p1[1] * n[0];
//		      p1 += Dim;
//		 }
//                 d0 = 0.;
//		 dof = buffer;
//                 for (j = 0; j < nvalues; j++) {
//                     d0 += *(pv++) * *(dof++);
//		 }
//		 d += d0 * *(w++);
//	     }
//
//             phgFree(buffer);
//	     phgFree(dofv);
//             phgFree(p0);
//             break;
//
//        default:
//             phgError(1, "%s: unknown projection %d\n", __func__, proj);
//    }
//    return d * phgGeomGetFaceArea(u->g, e, face);
//}
//
///* a x b */
//#define OP_CROSS0(a,b)  \
//	     ((*((a)+1)) * (*((b)+2)) - (*((a)+2)) * (*((b)+1)))
//#define OP_CROSS1(a,b)  \
//	     ((*((a)+2)) * (*(b)) - (*(a)) * (*((b)+2)))
//#define OP_CROSS2(a,b)  \
//	     ((*(a)) * (*((b)+1)) - (*((a)+1)) * (*(b)))
//
///* a \dot b */
//#define OP_DOT(a,b) \
//    ((*(a)) * (*(b)) + (*((a)+1)) * (*((b)+1)) + (*((a)+2)) * (*((b)+2)))
//
//FLOAT *
//phgQuadFaceADofCrossDof(SIMPLEX *e, int face, DOF *A, DOF *u, DOF_PROJ u_proj,
//			DOF *v, DOF_PROJ v_proj, int order, FLOAT *reval)
///* \int A ( u \corss n ) \cross ( v \cross n )  */
//{
//    GRID *g = u->g;
//    int i, j, v0, v1, v2;
//    int udim, vdim, dim;
//    FLOAT *pd, lambda[Dim + 1], alpha, area;
//    FLOAT *dofu, *pu;
//    FLOAT *dofv, *pv;
//    FLOAT *buffer0, *buffer1, *p0 = NULL, *p1 = NULL;
//    const FLOAT *p, *w;
//    QUAD *quad;
//    const FLOAT *n = NULL;	/* out normal vector */
//
//    assert(face >= 0 && face <= 3);
//    assert(u != NULL && (DofDim(u) % Dim == 0));
//    assert(reval!=NULL);
//    if(A!=NULL)
//       assert(DofDim(A)==1);
//
//    if (order < 0) {
//	i = DofTypeOrder(u, e);
//	if (v != NULL)
//	    j = DofTypeOrder(v, e);
//	else
//	    j = 0;
//	if (i < 0)
//	    i = j;
//	order = i + j;
//    }
//    quad = phgQuadGetQuad2D(order);
//
//    v0 = GetFaceVertex(face, 0);
//    v1 = GetFaceVertex(face, 1);
//    v2 = GetFaceVertex(face, 2);
//    lambda[face] = 0.;
//
//    udim = DofDim(u) / (u_proj == DOF_PROJ_DOT ? Dim : 1);
//
//    if (v != NULL){
//	vdim = DofDim(v) / (v_proj == DOF_PROJ_DOT ? Dim : 1);
//	if (vdim != udim)
//	    phgError(1, "%s: dimensions mismatch\n", __func__);
//    }
//
//    dim = DofDim(u);
//    dofu = phgAlloc(dim * sizeof(*dofu) * 4);
//    dofv = dofu + dim;
//    buffer0 = dofu + dim * 2;
//    buffer1 = dofu + dim * 3;
//
//    p = quad->points;
//    w = quad->weights;
//
//    pd=reval;
//    for(i = 0; i < udim; i++)
//        (*pd++) = 0.;
//
//    n = phgGeomGetFaceOutNormal(g, e, face);
//    area = phgGeomGetFaceArea(g, e, face);
//    for (i = 0; i < quad->npoints; i++, w++){
//        lambda[v0] = *(p++);
//        lambda[v1] = *(p++);
//        lambda[v2] = *(p++);
//        switch (u_proj) {
//             /* u */
//	    case DOF_PROJ_NONE:
//		 p0 = phgDofEval(u, e, lambda, buffer0);
//	         break;
//	     /* ( (u \dot n) */
//	    case DOF_PROJ_DOT:
//		 pu = phgDofEval(u, e, lambda, dofu);
//		 p0 = buffer0;
//	         for (j = 0; j < dim/Dim ; j++) {
//	             (*p0++) = OP_DOT (pu,n);
//		     pu += Dim;
//	  	 }
//	        break;
//	     /* ( (u  \cross  n) */
//            case DOF_PROJ_CROSS:
//		 pu = phgDofEval(u, e, lambda, dofu);
//		 p0 = buffer0;
//                 for (j = 0; j < dim/Dim; j++) {
//		     (*p0++) = OP_CROSS0(pu, n);
//		     (*p0++) = OP_CROSS1(pu, n);
//		     (*p0++) = OP_CROSS2(pu, n);
//		     pu += Dim;
//	         }
//		 break;
//           default:
//                 phgError(1, "%s: unknown projection %d\n", __func__, u_proj);
//        }
//
//        if(v == NULL){
//            p0=buffer0;
//            pd=reval;
//	    if (A != NULL){
//	        phgDofEval(A, e, lambda, &alpha);
//	        for (j = 0; j < udim ; j++)
//	            (*pd++) += (*p0++)*(*w)*alpha;
//	    }else{
//	        for(j = 0; j < udim ; j++)
//	        (*pd++) += (*p0++)*(*w);
//	    }
//        }else{
//            switch(v_proj) {
//              /* v */
//	      case DOF_PROJ_NONE:
//	           p1 = phgDofEval(v, e, lambda, buffer1);
//	           break;
//	      /* ( (v \dot n) */
//	      case DOF_PROJ_DOT:
//		   pv = phgDofEval(v, e, lambda, dofv);
//		   p1 = buffer1;
//	           for (j = 0; j < dim/Dim ; j++) {
//	               (*p1++) = OP_DOT ( pv , n ) ;
//		        pv += Dim;
//	  	   }
//	           break;
//	      /* ( (v  \cross  n) */
//              case DOF_PROJ_CROSS:
//		   pv = phgDofEval(v, e, lambda, dofv);
//		   p1 = buffer1;
//                   for (j = 0; j < dim/Dim; j++) {
//		       (*p1++) = OP_CROSS0(pv, n);
//		       (*p1++) = OP_CROSS1(pv, n);
//		       (*p1++) = OP_CROSS2(pv, n);
//		       pv += Dim;
//	           }
//		   break;
//              default:
//                   phgError(1, "%s: unknown projection %d\n", __func__, v_proj);
//            }
//
//            p0=buffer0;
//            p1=buffer1;
//            pd=reval;
//            if (A!=NULL){
//                phgDofEval(A, e, lambda, &alpha);
//                for (j = 0; j < udim/Dim; j++){
//	            (*pd++) += OP_CROSS0(p0, p1)*(*w)*alpha;
//	            (*pd++) += OP_CROSS1(p0, p1)*(*w)*alpha;
//	            (*pd++) += OP_CROSS2(p0, p1)*(*w)*alpha;
//                    p0 += Dim;
//	            p1 += Dim;
//                }
//            }else{
//                for (j = 0; j < udim/Dim; j++) {
//	            (*pd++) += OP_CROSS0(p0, p1)*(*w);
//	            (*pd++) += OP_CROSS1(p0, p1)*(*w);
//	            (*pd++) += OP_CROSS2(p0, p1)*(*w);
//                    p0 += Dim;
//	            p1 += Dim;
//                }
//           }
//        }
//    }/* end-for-i */
//
//    for(i = 0; i< udim; i++, pd++)
//        reval[i] *= area;
//    phgFree(dofu);
//
//    return reval;
//}
//
//FLOAT
//phgQuadDofNormP(SIMPLEX *e, DOF *u, int order, int p)
//{
//    int i, j, nvalues;
//    FLOAT d, d0, tmp;
//    const FLOAT *v1, *w;
//    QUAD *quad;
//
//    assert(u != NULL);
//    nvalues = DofDim(u);
//
//    if (order < 0) {
//        i = DofTypeOrder(u, e) * p;
//        if (i < 0)
//            i = 1;
//	order = i;
//    }
//    quad = phgQuadGetQuad3D(order);
//
//    d = 0.;
//    w = quad->weights;
//    v1 = phgQuadGetDofValues(e, u, quad);
//    for (i = 0; i < quad->npoints; i++){
//        tmp = 0.;
//        for (j = 0; j < nvalues; j++){
//            d0 = *(v1++);
//            tmp += Pow(Fabs(d0), p);
//	}
//        d += tmp * *(w++);
//    }
//
//    return d * phgGeomGetVolume(u->g, e);
//}
//
//#if 0	/*------------------------ old implementation -----------------------*/
//
//DOF *
//phgQuadFaceJumpN(DOF *u, DOF_PROJ proj, const char *name, int order, DOF *gn)
///* returns a DOF with one value on each face which is the (L^2 norm)^2 over
// * the face of the jump of 'u' acrossing the face.
// *
// * 'proj' specifies the projection to use: DOF_PROJ_NONE means no projection,
// * DOF_PROJ_DOT means \f$\vec{u} \cdot \vec{n}\f$, DOF_PROJ_CROSS means
// * \f$\vec{u} \times \vec{n}\f$.
// *
// * 'name' specifies the name of the returned DOF.
// *
// * 'order' specifies numerical integration order, if 'order' < 0 then the
// * numerical integration order is set to 2 times the order of 'u'.
// *
// * 'gn', if not NULL, specifies Neumann boundary condition. On a Neumann
// * face the jump is replaced by proj(u) - gn */
//{
//    static DOF_TYPE DOF_JUMP_ = { DofCache,
//	"Face jump", NULL, NULL, NULL, NULL, NULL, NULL, NULL,
//	NULL, NULL, NULL, NULL, FE_None,
//	TRUE, FALSE, -1, NFace, 0, -1, 1,
//	0, 0, 1, 0
//    };
//    char s[1024];
//    GRID *g = u->g;
//    SIMPLEX *e, *e1;
//    int i, j, k, dim, sign = 0;
//    INT I;
//    DOF *jump, *tmp;
//    FLOAT values[DofDim(u)];
//    FLOAT lambda[Dim + 1];
//    FLOAT d, d0, *p0, *p1, *p2;
//    FLOAT *w, *pts;
//    const FLOAT *n = NULL;
//#if USE_MPI
//    NEIGHBOUR_DATA *neigh_data;
//#endif
//    int v0, v1, v2;
//    QUAD *quad;
//
//    /* first, compute jumps at face quadrature points */
//    assert(!SpecialDofType(u->type));
//
//    if (proj != DOF_PROJ_NONE && DofDim(u) % Dim != 0)
//	phgError(1, "phgDofJumpFace: DOF \"%s\" has incorrect dimension for "
//		 "the operation %d\n", u->name, proj);
//    if (name == NULL) {
//	sprintf(s, "Jumps of %s", u->name);
//	name = s;
//    }
//
//    /* compute and store jumps at all quadrature points.
//     *
//     * FIXME: may need large amount of memory if order is high, better
//     *	      to use phgDofInitNeighbourData to get remote DOF on shared
//     *	      faces then integrate face by face, assuming the values on a
//     *	      face only depends on DOF on the face */
//    if (order < 0) {
//#warning FIXME!
//	order = (!DofIsHP(u) ? u->type->order : 2) * 2;
//    }
//    quad = phgQuadGetQuad2D(order);
//    dim = DofDim(u) / (proj == DOF_PROJ_DOT ? Dim : 1);
//    if (gn != NULL)
//        assert(DofDim(gn) == dim);
//
//    jump = phgDofNew(g, &DOF_JUMP_, dim * quad->npoints, "Jump tmp",
//			DofNoAction);
//    ForAllElements(g, e) {
//	BOOLEAN flag;
//	for (i = 0; i < NFace; i++) {
//	    /* determine direction of the face normal */
//	    if (HasLocalNeighbour(e, i)) {
//		/* towards the vertex with larger index */
//		e1 = e->neighbours[i];
//		sign = e1->verts[phgOppositeVertex(g, e, i, e1)] - e->verts[i];
//		flag = TRUE;
//	    }
//#if USE_MPI
//	    else if (HasRemoteNeighbour(e, i)) {
//		/* towards the submesh with larger rank */
//		sign = GetRNeighbour(g, e, i)->rank - g->rank;
//		flag = TRUE;
//	    }
//#endif
//	    else {
//		/* boundary face, do nothing (FIXME: set to 0?) */
//		flag = FALSE;
//	    }
//
//	    if (flag) {
//	        if (proj != DOF_PROJ_NONE) {
//		    n = phgGeomGetFaceNormal(g, e, i);
//		    if (sign < 0) {
//		        static FLOAT m[Dim];
//		        m[0] = -n[0];
//		        m[1] = -n[1];
//		        m[2] = -n[2];
//		        n = m;
//		    }
//	        }
//	        pts = quad->points;
//	        lambda[i] = 0.;
//	        GetFaceVertices(e, i, v0, v1, v2);
//	        p0 = DofFaceData(jump, e->faces[i]);
//	        for (k = 0; k < quad->npoints; k++) {
//		    lambda[v0] = *(pts++);
//		    lambda[v1] = *(pts++);
//		    lambda[v2] = *(pts++);
//		    phgDofEval(u, e, lambda, values);
//		    p1 = values;
//		    switch (proj) {
//		        case DOF_PROJ_NONE:
//			    if (sign > 0) {
//			        for (j = 0; j < dim; j++)
//				    *(p0++) += *(p1++);
//			    }
//			    else {
//			        for (j = 0; j < dim; j++)
//				    *(p0++) -= *(p1++);
//			    }
//			    break;
//		        case DOF_PROJ_DOT:
//			    for (j = 0; j < dim; j++) {
//			        *(p0++) +=
//				    n[0] * p1[0] + n[1] * p1[1] + n[2] * p1[2];
//			        p1 += Dim;
//			    }
//			    break;
//		        case DOF_PROJ_CROSS:
//			    for (j = 0; j < dim / Dim; j++) {
//			        *(p0++) += p1[1] * n[2] - p1[2] * n[1];
//			        *(p0++) += p1[2] * n[0] - p1[0] * n[2];
//			        *(p0++) += p1[0] * n[1] - p1[1] * n[0];
//			        p1 += Dim;
//			    }
//			    break;
//		        default:
//			    phgError(1, "%s:%d undefined projection.\n",
//				 __FILE__, __LINE__);
//		    }		/* endof switch */
//	        }		/* end of k-loop */
//	    }
//            else {
//		if (gn != NULL && (e->bound_type[i] & NEUMANN)) {
//		    FLOAT vg[DofDim(gn)];
//
//		    if (proj != DOF_PROJ_NONE)
//		        n = phgGeomGetFaceOutNormal(g, e, i);
//
//		    pts = quad->points;
//		    lambda[i] = 0.;
//		    GetFaceVertices(e, i, v0, v1, v2);
//		    p0 = DofFaceData(jump, e->faces[i]);
//		    for (k = 0; k < quad->npoints; k++) {
//		        lambda[v0] = *(pts++);
//		        lambda[v1] = *(pts++);
//		        lambda[v2] = *(pts++);
//		        phgDofEval(u, e, lambda, values);
//		        phgDofEval(gn, e, lambda, vg);
//		        p1 = values;
//		        p2 = vg;
//
//			switch (proj) {
//			    case DOF_PROJ_NONE:
//		 	         for (j = 0; j < dim; j++)
//				     *(p0++) = *(p2++) - *(p1++);
//				 break;
//			    case DOF_PROJ_DOT:
//			         for (j = 0; j < dim; j++) {
//				     *(p0++) = *(p2++) -
//				         n[0]*p1[0] - n[1]*p1[1] - n[2]*p1[2];
//				     p1 += Dim;
//				 }
//				 break;
//			    case DOF_PROJ_CROSS:
//				 for (j = 0; j < dim / Dim; j++) {
//				     *(p0++) = *(p2++) - p1[1]*n[2]+p1[2]*n[1];
//				     *(p0++) = *(p2++) - p1[2]*n[0]+p1[0]*n[2];
//				     *(p0++) = *(p2++) - p1[0]*n[1]+p1[1]*n[0];
//				     p1 += Dim;
//				 }
//				 break;
//			    default:
//				 phgError(1, "%s:%d undefined projection.\n",
//					 __FILE__, __LINE__);
//			}	/* endof switch */
//		    }		/* end of k-loop */
//		}		/* gn != NULL && boundary type is NEUMANN */
//	    }			/* flag ifelse  */
//	}			/* end of i-loop */
//    }				/* end of ForAllElements */
//
//#if USE_MPI
//    neigh_data = phgDofInitNeighbourData(jump, NULL);
//    for (I = 0; I < g->neighbours.count; I++) {
//	RNEIGHBOUR *rn = g->neighbours.list + I;
//	e = rn->local;
//	p0 = DofFaceData(jump, e->faces[rn->vertex]);
//	p1 = phgDofNeighbourData(neigh_data, e, rn->vertex, 0, NULL);
//	for (k = 0; k < jump->type->np_face * jump->dim; k++)
//	    *(p0++) += *(p1++);
//    }
//    phgDofReleaseNeighbourData(&neigh_data);
//#endif
//
//    /* then, integrate (sum) on each face */
//    tmp = jump;
//    jump = phgDofNew(g, &DOF_JUMP_, 1, name, DofNoAction);
//    p0 = DofFaceData(tmp, 0);
//    p1 = DofFaceData(jump, 0);
//    if (dim > 1) {
//	for (I = 0; I < g->nface; I++) {
//	    d = 0.0;
//	    w = quad->weights;
//	    for (k = 0; k < quad->npoints; k++, w++) {
//		d0 = 0.;
//		for (i = 0; i < dim; i++, p0++)
//		    d0 += (*p0) * (*p0);
//		d += d0 * (*w);
//	    }
//	    *(p1++) = phgGeomGetFaceAreaByIndex(g, I) * d;
//	}
//    }
//    else {
//	for (I = 0; I < g->nface; I++) {
//	    d = 0.0;
//	    w = quad->weights;
//	    for (k = 0; k < quad->npoints; k++, p0++, w++)
//		d += (*p0) * (*p0) * (*w);
//	    *(p1++) = phgGeomGetFaceAreaByIndex(g, I) * d;
//	}
//    }
//    phgDofFree(&tmp);
//    return jump;
//}
//
//#else	/*------------------------ new implementation -----------------------*/
//
//DOF *
//phgQuadFaceJumpN(DOF *u, DOF_PROJ proj, const char *name, int order, DOF *gn)
///* returns a DOF with one value on each face which is the (L^2 norm)^2 over
// * the face of the jump of 'u' acrossing the face.
// *
// * 'proj' specifies the projection to use: DOF_PROJ_NONE means no projection,
// * DOF_PROJ_DOT means \f$\vec{u} \cdot \vec{n}\f$, DOF_PROJ_CROSS means
// * \f$\vec{u} \times \vec{n}\f$.
// *
// * 'name' specifies the name of the returned DOF.
// *
// * 'order' specifies numerical integration order, if 'order' < 0 then the
// * numerical integration order is set to 2 times the order of 'u'.
// *
// * 'gn', if not NULL, specifies Neumann boundary condition, on a Neumann
// * face the jump is replaced by:
// * 	 u - gn		if 'proj' == DOF_PROJ_NONE
// * 	 u.n - gn	if 'proj' == DOF_PROJ_DOT, FIXME: use (u-gn).n instead?
// * 	 uxn - gn	if 'proj' == DOF_PROJ_CROSS
// */
//{
//    static DOF_TYPE DOF_JUMP_ = { DofCache,
//	"Face jump", NULL, NULL, NULL, NULL, NULL, NULL, NULL,
//	NULL, NULL, NULL, NULL, FE_None,
//	TRUE, FALSE, -1, NFace, 0, -1, 1,
//	0, 0, 1, 0
//    };
//    char s[1024];
//    GRID *g = u->g;
//    SIMPLEX *e;
//    int ii, jj, face, j, k, dim, dim0 = DofDim(u);
//    INT i;
//    DOF *jump, tmp;
//    DOF_TYPE *type;
//    FLOAT values[dim0], values1[dim0];
//    FLOAT lambda[Dim + 1];
//    FLOAT d, d0, d1, *p, *p0, *p1;
//    FLOAT *w, *pts, *buffer = NULL;
//    const FLOAT *n = NULL, *bas, *pb;
//    NEIGHBOUR_DATA *neigh;
//    SHORT *bases0 = NULL, *bases1 = NULL;
//    int nbases0 = 0, nbases1 = 0, nbas0, nbas1, v0, v1, v2;
//    QUAD *quad;
//    VEF_MAP *vef;
//    BOOLEAN neumann;
//    FE_SPACE fe_space = (!DofIsHP(u) ? u->type->fe_space :
//				       u->hp->info->fe_space);
//
//    assert(!SpecialDofType(u->type));	/* return 0 in this case? */
//
//    /* Note: only DG type is allowed (to be fixed when needed) */
//    if (fe_space != FE_L2 && fe_space != FE_None)
//	phgError(1, "%s: can't compute jumps of DOF \"%s\" "
//		    "(only DG types are allowed).\n", __func__, u->name);
//
//    if (proj != DOF_PROJ_NONE && DofDim(u) % Dim != 0)
//	phgError(1, "phgDofJumpFace: DOF \"%s\" has incorrect dimension for "
//		 "the operation %d\n", u->name, proj);
//
//    dim = dim0 / (proj == DOF_PROJ_DOT ? Dim : 1);
//    assert(gn == NULL || DofDim(gn) == dim);
//
//    if (name == NULL) {
//	sprintf(s, "Jumps of %s", u->name);
//	name = s;
//    }
//    jump = phgDofNew(g, &DOF_JUMP_, 1, name, DofNoAction);
//
//    vef = phgDofSetupVEFMap(g, jump, FACE_FLAG);
//    neigh = phgDofInitNeighbourData(u, NULL);
//
//    if (order < 0 && !DofIsHP(u))
//	order = u->type->order * 2;
//
//    if (order >= 0)
//	quad = phgQuadGetQuad2D(order);
//    else
//	quad = NULL;		/* make gcc happy */
//
//    if ((type = u->type) == NULL) {
//	/* create a temporary non hp DOF whose type will be set by
//	 * phgDofNeighbourNBas() to match the order of the neighbour.
//	 * This DOF is used to get the list of the bases for the neighbouring
//	 * element (bases1). */
//	DOF *dof;
//	dof = phgDofNew(g, type = u->hp->info->types[u->hp->max_order], u->dim,
//			"temp", DofNoData);
//	phgDofUnrefId(dof->type);
//	memcpy(&tmp, dof, sizeof(tmp));
//	dof->type = NULL;	/* shouldn't call phgDofUnrefId */
//	phgDofFree(&dof);
//    }
//
//#if USE_OMP
//#pragma omp parallel \
//	firstprivate(tmp, quad, nbases0, nbases1, bases0, bases1) \
//	private(i, j, k, e, face, neumann, nbas0, nbas1, ii, jj, v0, v1, v2, \
//		pts, w, lambda, d, d0, d1, values, values1, \
//		p0, p, p1, pb, bas, n)
//{
//#pragma omp for
//#endif	/* USE_OMP */
//    for (i = 0; i < g->nface; i++) {
//	if (g->types_face[i] == UNREFERENCED)
//	    continue;
//	e = vef->Fmap[i];
//	face = vef->Find[i];
//
//	if (!(e->bound_type[face] & (INTERIOR | NEUMANN)))
//	    continue;		/* non Neumann boundary */
//
//	neumann = (e->bound_type[face] & NEUMANN);
//	if (neumann && gn == NULL)
//	    continue;
//
//	nbas0 = phgDofGetBasesOnFace(u, e, face, NULL);
//	if (!neumann) {
//	    if (!DofIsHP(u)) {
//		nbas1 = nbas0;
//	    }
//	    else {
//		nbas1 = phgDofNeighbourNBas(neigh, e, face, &tmp.type);
//		if (order < 0) {
//		    assert(DofIsHP(u));
//		    j = u->hp->info->types[u->hp->elem_order[e->index]]->order;
//		    quad = phgQuadGetQuad2D(j + tmp.type->order);
//		}
//	    }
//	}
//	else {
//	    nbas1 = 0;
//	    if (order < 0) {
//		assert(DofIsHP(u));
//		j = u->hp->info->types[u->hp->elem_order[e->index]]->order;
//		if (gn->type == DOF_CONSTANT)
//		    k = 0;
//		else if (gn->type == DOF_ANALYTIC)
//		    k = j;
//		else
//		    k = DofFaceOrder(gn, i);
//		quad = phgQuadGetQuad2D(j + k);
//	    }
//	}
//
//	if (nbases0 < nbas0) {
//	    nbases0 = nbas0;
//	    phgFree(bases0);
//	    bases0 = phgAlloc(nbases0 * sizeof(*bases0));
//	}
//	phgDofGetBasesOnFace(u, e, face, bases0);
//
//	if (!neumann && nbas0 != nbas1) {
//	    if (nbases1 < nbas1) {
//		nbases1 = nbas1;
//		phgFree(bases1);
//		bases1 = phgAlloc(nbases1 * sizeof(*bases1));
//	    }
//	    phgDofGetBasesOnFace(&tmp, e, face, bases1);
//	}
//
//	GetFaceVertices(e, face, v0, v1, v2);
//
//	pts = quad->points;
//	w   = quad->weights;
//	lambda[face] = 0.;
//
//	if (!DofIsHP(u) && buffer == NULL) {
//	    /* pre-compute values of basis functions at quadrature points */
//#if USE_OMP
//#pragma omp flush(buffer)
//#pragma omp critical (face_jump)
//#endif	/* USE_OMP */
//	    if (buffer == NULL) {
//		/* only one thread will execute this block */
//		FLOAT *buffer_tmp;
//		int max, min;
//		min = max = bases0[0];
//		for (jj = 1; jj < nbas0; jj++) {
//		    if (min > bases0[jj])
//			min = bases0[jj];
//		    else if (max < bases0[jj])
//			max = bases0[jj];
//		}
//		buffer_tmp = phgAlloc(quad->npoints * nbas0 * type->dim
//						* sizeof(*buffer_tmp));
//		for (k = 0; k < quad->npoints; k++) {
//		    lambda[v0] = *(pts++);
//		    lambda[v1] = *(pts++);
//		    lambda[v2] = *(pts++);
//		    p = buffer_tmp + k * nbas0 * type->dim;
//		    bas = type->BasFuncs(u, e, min, max + 1, lambda);
//		    for (jj = 0; jj < nbas0; jj++, p += type->dim)
//			memcpy(p, bas + (bases0[jj] - min) * type->dim,
//				  type->dim * sizeof(*buffer_tmp));
//		}
//		pts = quad->points;	/* restore pts */
//		buffer = buffer_tmp;
//#if USE_OMP
//#pragma omp flush(buffer)
//#endif	/* USE_OMP */
//	    }
//	}
//
//	d = 0.;
//	for (k = 0; k < quad->npoints; k++) {
//	    lambda[v0] = *(pts++);
//	    lambda[v1] = *(pts++);
//	    lambda[v2] = *(pts++);
//	    memset(values, 0, dim0 * sizeof(*values));
//	    for (j = 0; j < nbas0; j++) {
//		ii = bases0[j];
//		if (/*FALSE &&*/ !DofIsHP(u)) {
//		    bas = buffer + (k * nbas0 + j) * type->dim;
//		}
//		else {
//		    bas = type->BasFuncs(u, e, ii, ii + 1, lambda);
//		}
//		p0 = u->data + phgDofMapE2D(u, e, ii * u->dim);
//		p = values;
//		if (neumann || nbas0 != nbas1) {
//		    for (ii = 0; ii < u->dim; ii++) {
//			d0 = *(p0++);
//			for (jj = 0, pb = bas; jj < type->dim; jj++)
//			    *(p++) += d0 * *(pb++);
//		    }
//		}
//		else {
//		    p1 = phgDofNeighbourData(neigh, e, face, j, NULL);
//		    for (ii = 0; ii < u->dim; ii++) {
//			d0 = *(p0++) - *(p1++);
//			for (jj = 0, pb = bas; jj < type->dim; jj++)
//			    *(p++) += d0 * *(pb++);
//		    }
//		}
//	    }
//#if 0
///*if (i == 4)*/ {
//FLOAT values0[dim0], lambda1[Dim + 1];
//int u0, u1, u2;
//phgDofEval(u, e, lambda, values0);
//SIMPLEX *e1 = e->neighbours[face];
//ii = phgOppositeVertex(g, e, face, e1);
//GetFaceVertices(e1, ii, u0, u1, u2);
//pts -= 3;
//lambda1[ii] = 0.;
//lambda1[u0] = *(pts++);
//lambda1[u1] = *(pts++);
//lambda1[u2] = *(pts++);
//phgDofEval(u, e1, lambda1, values1);
//for (ii = 0; ii < dim0; ii++)
//phgInfo(-1, "face=%d, k=%d, ii = %d, value=%e, error=%e\n", i, k, ii, values[ii], values[ii] - values0[ii] + values1[ii]);
//}
//#endif
//
//	    if (neumann) {
//		phgDofEval(gn, e, lambda, values1);
//	    }
//	    else if (nbas0 != nbas1) {
//		for (j = 0; j < nbas1; j++) {
//		    ii = bases1[j];
//		    bas = type->BasFuncs(&tmp, e, ii, ii + 1, lambda);
//		    p0 = phgDofNeighbourData(neigh, e, face, j, NULL);
//		    p = values;
//		    for (ii = 0; ii < u->dim; ii++) {
//			d0 = *(p0++);
//			for (jj = 0, pb = bas; jj < type->dim; jj++)
//			    *(p++) -= d0 * *(pb++);
//		    }
//		}
//	    }
//
//	    /* projection */
//	    d0 = 0.;
//	    switch (proj) {
//	        case DOF_PROJ_NONE:
//		    if (neumann) {
//			p1 = values1;
//			for (ii = 0, p = values; ii < dim0; ii++) {
//			    d1 = *(p++) - *(p1++);
//			    d0 += d1 * d1;
//			}
//		    }
//		    else {
//			for (ii = 0, p = values; ii < dim0; ii++, p++)
//			    d0 += *p * *p;
//		    }
//		    break;
//	        case DOF_PROJ_DOT:
//		    n = phgGeomGetFaceNormal(g, e, face);
//		    if (neumann) {
//			p1 = values1;
//			for (ii = 0, p = values; ii < dim; ii++, p += Dim) {
//			    d1 = n[0]*p[0] + n[1]*p[1] + n[2]*p[2] - *(p1++);
//		            d0 += d1 * d1;
//			}
//		    }
//		    else {
//			for (ii = 0, p = values; ii < dim; ii++, p += Dim) {
//			    d1 = n[0] * p[0] + n[1] * p[1] + n[2] * p[2];
//		            d0 += d1 * d1;
//			}
//		    }
//		    break;
//	        case DOF_PROJ_CROSS:
//		    n = phgGeomGetFaceNormal(g, e, face);
//		    if (neumann) {
//			p1 = values1;
//			for (ii = 0, p = values; ii < dim / Dim; ii++) {
//		            d1 = p[1] * n[2] - p[2] * n[1] - *(p1++);
//			    d0 += d1 * d1;
//		            d1 = p[2] * n[0] - p[0] * n[2] - *(p1++);
//			    d0 += d1 * d1;
//		            d1 = p[0] * n[1] - p[1] * n[0] - *(p1++);
//			    d0 += d1 * d1;
//			    p += Dim;
//			}
//		    }
//		    else {
//			for (ii = 0, p = values; ii < dim / Dim; ii++) {
//		            d1 = p[1] * n[2] - p[2] * n[1];
//			    d0 += d1 * d1;
//		            d1 = p[2] * n[0] - p[0] * n[2];
//			    d0 += d1 * d1;
//		            d1 = p[0] * n[1] - p[1] * n[0];
//			    d0 += d1 * d1;
//			    p += Dim;
//			}
//		    }
//		    break;
//	        default:
//		    phgError(1, "%s: invalid projection %d.\n", __func__, proj);
//	    }		/* endswitch */
//	    d += d0 * *(w++);
//	}	/* endfor k */
//	*DofFaceData(jump, i) = d * phgGeomGetFaceAreaByIndex(g, i);
//    }	/* endfor i */
//
//    phgFree(bases0);
//    phgFree(bases1);
//
//#if USE_OMP
//}
//#endif	/* USE_OMP */
//
//    phgFree(buffer);
//
//    phgDofFreeVEFMap(&vef);
//    phgDofReleaseNeighbourData(&neigh);
//
//    return jump;
//}
//
//#endif	/*------------------------ new implementation -----------------------*/
//
///*------------------------------ 3D functions --------------------------------*/
//
//FLOAT
//phgQuadDofDotDof(SIMPLEX *e, DOF *u, DOF *v, int order)
///* computes \int u \cdot v on element 'e' (inner product),
// * using quadrature rule 'quad'.
// */
//{
//    int i, j, nvalues;
//    FLOAT d, d0;
//    const FLOAT *v1, *v2, *w;
//    QUAD *quad;
//
//    nvalues = DofDim(u);
//    if (v != NULL && nvalues != DofDim(v))
//	phgError(1, "%s:%d: dimensions of \"%s\" and \"%s\" don't match\n",
//		 __FILE__, __LINE__, u->name, v->name);
//
//    if (order < 0) {
//	i = DofTypeOrder(u, e);
//	j = DofTypeOrder(v, e);
//	if (i < 0 && j < 0) {
//	    phgInfo(-1, "phgQuadDofDotDof: don't use QUAD_DEFAULT when both "
//		    "DOF types are analytic.\n");
//	    phgError(1, "phgQuadDofDotDof: can't determine quadrature order, "
//			"abort.\n");
//	}
//	if (i < 0)
//	    i = j;
//	else if (j < 0)
//	    j = i;
//	order = i + j;
//    }
//    quad = phgQuadGetQuad3D(order);
//
//    w = quad->weights;
//    v1 = phgQuadGetDofValues(e, u, quad);
//    v2 = phgQuadGetDofValues(e, v, quad);
//
//    if (nvalues == 1) {		/* faster code for special case */
//	d = 0.;
//	for (i = 0; i < quad->npoints; i++)
//	    d += *(v1++) * *(v2++) * *(w++);
//    }
//    else {
//	d = 0.;
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    for (j = 0; j < nvalues; j++)
//		d0 += *(v1++) * *(v2++);
//	    d += d0 * *(w++);
//	}
//    }
//
//    return d * phgGeomGetVolume(u->g, e);
//}
//
//FLOAT
//phgQuadGradBasAGradBas(SIMPLEX *e, DOF *u, int n, DOF *A, DOF *v, int m,
//		       int order)
//{
//    int i, j, k, nvalues = DofTypeDim(u), nn, An;
//    FLOAT d, d0;
//    const FLOAT *g1, *g2, *g2_tmp, *w, *coef;
//    QUAD *quad;
//
//    assert(!SpecialDofType(u->type) && !SpecialDofType(v->type));
//    assert(nvalues == DofTypeDim(v));
//
//    if (order < 0) {
//	order = BasisOrder(u, e, n) - 1 + BasisOrder(v, e, m) - 1;
//	if (A != NULL && DofTypeOrder(A, e) >= 0)
//	    order += DofTypeOrder(A, e);
//	if (order < 0)
//	    order = 0;
//    }
//    quad = phgQuadGetQuad3D(order);
//
//    d = 0.;
//    g1 = phgQuadGetBasisGradient(e, u, n, quad);
//    g2 = phgQuadGetBasisGradient(e, v, m, quad);
//    w = quad->weights;
//    if (NULL == A) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    for (j = 0; j < nvalues; j++) {
//		d0 += g1[0] * g2[0] + g1[1] * g2[1] + g1[2] * g2[2];
//		g1 += Dim;
//		g2 += Dim;
//	    }
//	    d += d0 * (*(w++));
//	}
//	return d * phgGeomGetVolume(u->g, e);
//    }
//
//    An = DofDim(A);
//    coef = phgQuadGetDofValues(e, A, quad);
//    if (1 == An) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    for (j = 0; j < nvalues; j++) {
//		d0 += g1[0] * g2[0] + g1[1] * g2[1] + g1[2] * g2[2];
//		g1 += Dim;
//		g2 += Dim;
//	    }
//	    d += d0 * (*(w++)) * *(coef++);
//	}
//    }
//    else if (An == (nn = nvalues * Dim)) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    for (j = 0; j < nvalues; j++) {
//		d0 +=
//		    g1[0] * g2[0] * coef[0] + g1[1] * g2[1] * coef[1] +
//		    g1[2] * g2[2] * coef[2];
//		g1 += Dim;
//		g2 += Dim;
//		coef += Dim;
//	    }
//	    d += d0 * (*(w++));
//	}
//    }
//    else if (An == nn * nn) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0;
//	    g2_tmp = g2;
//	    for (j = 0; j < nn; j++) {
//		g2 = g2_tmp;
//		for (k = 0; k < nn; k++) {
//		    d0 += *(g1) * *(g2++) * *(coef++);
//		}
//		g1++;
//	    }
//	    d += d0 * *(w++);
//	}
//    }
//    else {
//	phgError(1, "%s:%d: dimensions mismatch: coefficent A  %s (%d)",
//		 __FILE__, __LINE__, DofTypeName(A), DofTypeDim(A));
//    }
//
//    return d * phgGeomGetVolume(u->g, e);
//}
//
//FLOAT *
//phgQuadDofTimesBas(SIMPLEX *e, DOF *u, DOF *v, int n, int order, FLOAT *res)
///* computes \int 'u' * ('n'-th basis function of 'v') on element 'e'
// * using quadrature rule 'quad'. The results are returned in the user provided
// * array 'res' whose size should be greater than or equal to u->dim.
// */
//{
//    int i, j, nvalues;
//    const FLOAT *bas, *w, *f;
//    FLOAT d;
//    QUAD *quad;
//
//    assert(v != NULL && !SpecialDofType(v->type) && DofTypeDim(v) == 1);
//
//    if (order < 0) {
//	i = DofTypeOrder(u, e);
//	j = DofTypeOrder(v, e);
//	if (i < 0)
//	    i = j;
//	order = i + j;
//    }
//    quad = phgQuadGetQuad3D(order);
//
//    nvalues = DofDim(u);
//    f = phgQuadGetDofValues(e, u, quad);
//    bas = phgQuadGetBasisValues(e, v, n, quad);
//
//    w = quad->weights;
//    if (nvalues == 1) {		/* faster code for special case */
//	d = 0.0;
//	for (i = 0; i < quad->npoints; i++) {
//	    d += *(bas++) * *(w++) * *(f++);
//	}
//	res[0] = d * phgGeomGetVolume(u->g, e);
//    }
//    else {
//	for (j = 0; j < nvalues; j++)
//	    res[j] = 0;
//	for (i = 0; i < quad->npoints; i++) {
//	    d = *(bas++) * *(w++);
//	    for (j = 0; j < nvalues; j++)
//		res[j] += d * *(f++);
//	}
//	d = phgGeomGetVolume(u->g, e);
//	for (j = 0; j < nvalues; j++)
//	    res[j] *= d;
//    }
//
//    return res;
//}
//
//#if 0				/* note: use phgQuadBasABas */
///* computes integration of
// *  	('n'-th basis function of 'u')
// *  	\cdot
// *  	('m'-th basis function of 'v')
// * on element 'e' (inner product), using quadrature rule 'quad'.
// */
//FLOAT
//phgQuadBasDotBas(SIMPLEX *e, DOF *u, int n, DOF *v, int m, int order)
//{
//    int i, j, nvalues = DofTypeDim(u);
//    FLOAT *g1, *g2, *w;
//    FLOAT d, d0;
//    QUAD *quad;
//
//    assert(!SpecialDofType(u->type) && !SpecialDofType(v->type));
//
//    if (nvalues != DofTypeDim(v))
//	phgError(1, "%s:%d: dimensions mismatch: %s (%d) <==> %s ($d))\n",
//		 __FILE__, __LINE__, DofTypeName(u), DofTypeDim(u),
//		 DofTypeName(v), DofTypeDim(v));
//
//    if (order < 0)
//	order = BasisOrder(u, e, n) + BasisOrder(v, e, m);
//    quad = phgQuadGetQuad3D(order);
//
//    g1 = phgQuadGetBasisValues(e, u, n, quad);
//    g2 = phgQuadGetBasisValues(e, v, m, quad);
//    d = 0.;
//    w = quad->weights;
//    for (i = 0; i < quad->npoints; i++) {
//	d0 = 0.;
//	for (j = 0; j < nvalues; j++) {
//	    d0 += *(g1++) * (*(g2++));
//	}
//	d += d0 * (*(w++));
//    }
//    return d * phgGeomGetVolume(u->g, e);
//}
//#endif
//
//FLOAT
//phgQuadBasABas(SIMPLEX *e, DOF *u, int n, DOF *A, DOF *v, int m, int order)
///* computes integration of
// *  	('n'-th basis function of 'u')
// *  	\cdot
// *       (coefficient function 'A')
// *       \cdot
// *  	('m'-th basis function of 'v')
// * on element 'e' (inner product), using quadrature rule 'quad'.
// *
// */
//{
//    int i, j, k, nvalues = DofTypeDim(u), An;
//    const FLOAT *g1, *g2, *g2_tmp, *coef, *w;
//    FLOAT d, d0;
//    QUAD *quad;
//
//    assert(!SpecialDofType(u->type) && !SpecialDofType(v->type));
//
//    if (nvalues != DofTypeDim(v))
//	phgError(1, "%s:%d: dimensions mismatch: %s (%d) <==> %s ($d))\n",
//		 __FILE__, __LINE__, DofTypeName(u), DofTypeDim(u),
//		 DofTypeName(v), DofTypeDim(v));
//
//    if (order < 0) {
//	order = BasisOrder(u, e, n) + BasisOrder(v, e, m);
//	if (A != NULL && DofTypeOrder(A, e) >= 0)
//	    order += DofTypeOrder(A, e);
//    }
//    quad = phgQuadGetQuad3D(order);
//
//    g1 = phgQuadGetBasisValues(e, u, n, quad);
//    g2 = phgQuadGetBasisValues(e, v, m, quad);
//    d = 0.;
//    w = quad->weights;
//    if (NULL == A) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    for (j = 0; j < nvalues; j++) {
//		d0 += *(g1++) * *(g2++);
//	    }
//	    d += d0 * *(w++);
//	}
//	return d * phgGeomGetVolume(u->g, e);
//    }
//
//    An = DofDim(A);
//    coef = phgQuadGetDofValues(e, A, quad);
//    if (1 == An) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    for (j = 0; j < nvalues; j++) {
//		d0 += *(g1++) * (*(g2++));
//	    }
//	    d += d0 * (*(w++)) * *(coef++);
//	}
//    }
//    else if (An == nvalues) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    for (j = 0; j < nvalues; j++) {
//		d0 += *(g1++) * *(g2++) * *(coef++);
//	    }
//	    d += d0 * *(w++);
//	}
//    }
//    else if (An == nvalues * nvalues) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    g2_tmp = g2;
//	    for (j = 0; j < nvalues; j++) {
//		g2 = g2_tmp;
//		for (k = 0; k < nvalues; k++) {
//		    d0 += *(g1) * *(g2++) * *(coef++);
//		}
//		g1++;
//	    }
//	    d += d0 * *(w++);
//	}
//    }
//    else {
//	phgError(1, "%s:%d: dimensions mismatch: coefficent A  %s (%d)",
//		 __FILE__, __LINE__, DofTypeName(A), DofTypeDim(A));
//    }
//
//    return d * phgGeomGetVolume(u->g, e);
//}
//
//#if 0				/* note: use phgQuadCurlBasACurlBas */
///* computes integration of
// *        (curl of 'n'-th basis function of 'u')
// *        \cdot
// *        (curl of 'm'-th basis function of 'v')
// * on element 'e' using quadrature rule 'quad'.
// */
//FLOAT
//phgQuadCurlBasDotCurlBas(SIMPLEX *e, DOF *u, int n, DOF *v, int m, int order)
//{
//    int i, j, nvalues = DofTypeDim(u);
//    FLOAT *g1, *g2, *w;
//    FLOAT d, d0;
//    QUAD *quad;
//
//    assert(!SpecialDofType(u->type) && !SpecialDofType(v->type));
//
//    if (nvalues != DofTypeDim(v))
//	phgError(1, "%s:%d, dimensions mismatch: curl(%s) <==> curl(%s)\n",
//		 __FILE__, __LINE__, u->name, v->name);
//
//    if (order < 0)
//	order = BasisOrder(u, e, n) - 1 + BasisOrder(v, e, m) - 1;
//    quad = phgQuadGetQuad3D(order);
//
//    g1 = phgQuadGetBasisCurl(e, u, n, quad);
//    g2 = phgQuadGetBasisCurl(e, v, m, quad);
//
//    d = 0.;
//    w = quad->weights;
//    for (i = 0; i < quad->npoints; i++) {
//	d0 = 0.;
//	for (j = 0; j < nvalues; j++) {
//	    d0 += *(g1++) * (*(g2++));
//	}
//	d += d0 * (*(w++));
//    }
//
//    return d * phgGeomGetVolume(u->g, e);
//}
//#endif
//
//FLOAT
//phgQuadCurlBasACurlBas(SIMPLEX *e, DOF *u, int n, DOF *A, DOF *v, int m,
//		       int order)
//{
//    int i, j, k, nvalues = DofTypeDim(u), An;
//    const FLOAT *g1, *g2, *g2_tmp, *w, *coef;
//    FLOAT d, d0;
//    QUAD *quad;
//
//    assert(!SpecialDofType(u->type) && !SpecialDofType(v->type));
//
//    if (nvalues != DofTypeDim(v))
//	phgError(1, "%s:%d, dimensions mismatch: curl(%s) <==> curl(%s)\n",
//		 __FILE__, __LINE__, u->name, v->name);
//
//    if (order < 0) {
//	order = BasisOrder(u, e, n) - 1 + BasisOrder(v, e, m) - 1;
//        if (A != NULL && DofTypeOrder(A, e) >= 0)
//	    order += DofTypeOrder(A, e);
//	if (order < 0)
//	    order = 0;
//    }
//    quad = phgQuadGetQuad3D(order);
//
//    g1 = phgQuadGetBasisCurl(e, u, n, quad);
//    g2 = phgQuadGetBasisCurl(e, v, m, quad);
//    d = 0.;
//    w = quad->weights;
//    if (NULL == A) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    for (j = 0; j < nvalues; j++) {
//		d0 += *(g1++) * (*(g2++));
//	    }
//	    d += d0 * (*(w++));
//	}
//	return d * phgGeomGetVolume(u->g, e);
//    }
//
//    An = DofDim(A);
//    coef = phgQuadGetDofValues(e, A, quad);
//    if (1 == An) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    for (j = 0; j < nvalues; j++) {
//		d0 += *(g1++) * *(g2++);
//	    }
//	    d += d0 * *(w++) * *(coef++);
//	}
//    }
//    else if (An == nvalues) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    for (j = 0; j < nvalues; j++) {
//		d0 += *(g1++) * *(g2++) * *(coef++);
//	    }
//	    d += d0 * *(w++);
//	}
//
//    }
//    else if (An == nvalues * nvalues) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    g2_tmp = g2;
//	    for (j = 0; j < nvalues; j++) {
//		g2 = g2_tmp;
//		for (k = 0; k < nvalues; k++) {
//		    d0 += *(g1) * *(g2++) * *(coef++);
//		}
//		g1++;
//	    }
//	    d += d0 * *(w++);
//	}
//    }
//    else {
//	phgError(1, "%s:%d: dimensions mismatch: coefficent A  %s (%d)",
//		 __FILE__, __LINE__, DofTypeName(A), DofTypeDim(A));
//    }
//
//    return d * phgGeomGetVolume(u->g, e);
//}
//
//FLOAT
//phgQuadBasACurlBas(SIMPLEX *e, DOF *u, int n, DOF *A, DOF *v, int m,
//		       int order)
//{
//    int i, j, k, nvalues = DofTypeDim(u), An;
//    const FLOAT *g1, *g2, *g2_tmp, *w, *coef;
//    FLOAT d, d0;
//    QUAD *quad;
//
//    assert(!SpecialDofType(u->type) && !SpecialDofType(v->type));
//
//    if (nvalues != DofTypeDim(v))
//	phgError(1, "%s:%d, dimensions mismatch: curl(%s) <==> curl(%s)\n",
//		 __FILE__, __LINE__, u->name, v->name);
//
//    if (order < 0) {
//	order = BasisOrder(u, e, n) + BasisOrder(v, e, m) - 1;
//        if (A != NULL && DofTypeOrder(A, e) >= 0)
//	    order += DofTypeOrder(A, e);
//	if (order < 0)
//	    order = 0;
//    }
//    quad = phgQuadGetQuad3D(order);
//
//    g1 = phgQuadGetBasisValues(e, u, n, quad);
//    g2 = phgQuadGetBasisCurl(e, v, m, quad);
//    d = 0.;
//    w = quad->weights;
//    if (NULL == A) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    for (j = 0; j < nvalues; j++) {
//		d0 += *(g1++) * (*(g2++));
//	    }
//	    d += d0 * (*(w++));
//	}
//	return d * phgGeomGetVolume(u->g, e);
//    }
//
//    An = DofDim(A);
//    coef = phgQuadGetDofValues(e, A, quad);
//    if (1 == An) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    for (j = 0; j < nvalues; j++) {
//		d0 += *(g1++) * *(g2++);
//	    }
//	    d += d0 * *(w++) * *(coef++);
//	}
//    }
//    else if (An == nvalues) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    for (j = 0; j < nvalues; j++) {
//		d0 += *(g1++) * *(g2++) * *(coef++);
//	    }
//	    d += d0 * *(w++);
//	}
//
//    }
//    else if (An == nvalues * nvalues) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    g2_tmp = g2;
//	    for (j = 0; j < nvalues; j++) {
//		g2 = g2_tmp;
//		for (k = 0; k < nvalues; k++) {
//		    d0 += *(g1) * *(g2++) * *(coef++);
//		}
//		g1++;
//	    }
//	    d += d0 * *(w++);
//	}
//    }
//    else {
//	phgError(1, "%s:%d: dimensions mismatch: coefficent A  %s (%d)",
//		 __FILE__, __LINE__, DofTypeName(A), DofTypeDim(A));
//    }
//
//    return d * phgGeomGetVolume(u->g, e);
//}
//
//FLOAT
//phgQuadFuncDotBas(SIMPLEX *e, DOF_USER_FUNC userfunc, DOF *u, int n,
//		  int order)
///* computes \int f * ('n'-th basis function of 'u') on element 'e'
// * using quadrature rule 'quad'. */
//{
//    int i, j, nvalues;
//    const FLOAT *v, *bas, *funcvalues, *w;
//    FLOAT d, d0;
//    QUAD *quad;
//
//    assert(!SpecialDofType(u->type));
//
//    if (order < 0)
//	order = DofTypeOrder(u, e) + BasisOrder(u, e, n);
//    quad = phgQuadGetQuad3D(order);
//
//    bas = phgQuadGetBasisValues(e, u, n, quad);
//    funcvalues = phgQuadGetFuncValues(u->g, e, DofTypeDim(u), userfunc, quad);
//    w = quad->weights;
//    nvalues = DofTypeDim(u);
//
//    d = 0.;
//    for (v = funcvalues, i = 0; i < quad->npoints; i++) {
//	d0 = 0.;
//	for (j = 0; j < nvalues; j++) {
//	    d0 += *(bas++) * (*(v++));
//	}
//	d += d0 * (*(w++));
//    }
//
//    return d * phgGeomGetVolume(u->g, e);
//}
//
//FLOAT
//phgQuadDofDotBas(SIMPLEX *e, DOF *u, DOF *v, int n, int order)
///* computes \int 'u' * ('n'-th basis function of 'v') on element 'e'
// * using quadrature rule 'quad'.
// */
//{
//    int i, j, nvalues;
//    FLOAT d, d0;
//    const FLOAT *bas, *dof, *w;
//    QUAD *quad;
//
//    assert(!SpecialDofType(v->type));
//
//    if (order < 0) {
//	i = DofTypeOrder(u, e);
//	j = DofTypeOrder(v, e);
//	if (i < 0)
//	    i = j;
//	order = i + j;
//    }
//    quad = phgQuadGetQuad3D(order);
//
//    nvalues = DofDim(u);
//    if(nvalues != DofTypeDim(v))
//	phgError(1,"%s:%d: dimension mismatch\n", __FILE__, __LINE__);
//
//    /* TODO: cache basis functions or values (analytic) of u */
//    dof = phgQuadGetDofValues(e, u, quad);
//    bas = phgQuadGetBasisValues(e, v, n, quad);
//    w = quad->weights;
//    d = 0.;
//    for (i = 0; i < quad->npoints; i++) {
//	d0 = 0.;
//	for (j = 0; j < nvalues; j++) {
//	    d0 += *(bas++) * *(dof++);
//	}
//	d += d0 * *(w++);
//    }
//
//    return d * phgGeomGetVolume(u->g, e);
//}
//
//FLOAT
//phgQuadDofABas(SIMPLEX *e, DOF *u, DOF *A, DOF *v, int m, int order)
//	/*
//	 * computes integration of
//	 *        DOF u
//	 *        \cdot
//	 *        A coefficient
//	 *        \cdot
//	 *        ('m'-th basis function of 'v')
//	 *      on element 'e' using quadrature rule 'quad'.
//	 */
//{
//    int i, j, k, nvalues = DofDim(u), An;
//    const FLOAT *g1, *g2, *g2_tmp, *coef, *w;
//    FLOAT d, d0;
//    QUAD *quad;
//
//    assert(!SpecialDofType(u->type) && !SpecialDofType(v->type));
//    assert(nvalues == DofTypeDim(v));
//
//    if (order < 0) {
//	order = ((j = DofTypeOrder(u, e)) >= 0 ? j : BasisOrder(v, e, m));
//	order += BasisOrder(v, e, m);
//        if (A != NULL && DofTypeOrder(A, e) >= 0)
//	    order += DofTypeOrder(A, e);
//    }
//    quad = phgQuadGetQuad3D(order);
//
//    d = 0.;
//    g1 = phgQuadGetDofValues(e, u, quad);
//    g2 = phgQuadGetBasisValues(e, v, m, quad);
//    w = quad->weights;
//
//    if (A == NULL) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    for (j = 0; j < nvalues; j++) {
//		d0 += *(g1++) * *(g2++);
//	    }
//	    d += d0 * (*(w++));
//	}
//	return d * phgGeomGetVolume(u->g, e);
//    }
//
//    An = DofDim(A);
//    coef = phgQuadGetDofValues(e, A, quad);
//    if (1 == An) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    for (j = 0; j < nvalues; j++) {
//		d0 += *(g1++) * *(g2++);
//	    }
//	    d += d0 * *(w++) * *(coef++);
//	}
//    }
//    else if (An == nvalues) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    for (j = 0; j < nvalues; j++) {
//		d0 += *(g1++) * *(g2++) * *(coef++);
//	    }
//	    d += d0 * *(w++);
//	}
//    }
//    else if (An == nvalues * nvalues) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    g2_tmp = g2;
//	    for (j = 0; j < nvalues; j++) {
//		g2 = g2_tmp;
//		for (k = 0; k < nvalues; k++)
//		    d0 += *g1 * *(g2++) * *(coef++);
//		g1++;
//	    }
//	    d += d0 * *(w++);
//	}
//
//    }
//    else {
//	phgError(1, "%s:%d: dimensions mismatch: coefficent A  %s (%d)",
//		 __FILE__, __LINE__, DofTypeName(A), DofTypeDim(A));
//    }
//
//    return d * phgGeomGetVolume(u->g, e);
//}
//
//FLOAT
//phgQuadDofAGradBas(SIMPLEX *e, DOF *u, DOF *A, DOF *v, int m, int order)
//	/*
//	 * computes integration of
//	 *        DOF u
//	 *        \cdot
//	 *        A coefficient
//	 *        \cdot
//	 *        (gradient of 'm'-th basis function of 'v')
//	 *      on element 'e' using quadrature rule 'quad'.
//	 */
//{
//    int i, j, k, nvalues = DofDim(u), An;
//    const FLOAT *g1, *g2, *g2_tmp, *coef, *w;
//    FLOAT d, d0;
//    QUAD *quad;
//
//    assert(!SpecialDofType(v->type));
//    assert(nvalues == DofTypeDim(v) * Dim);
//
//    if (order < 0) {
//	order = ((j = DofTypeOrder(u, e)) >= 0 ? j : BasisOrder(v, e, m));
//	order += BasisOrder(v, e, m) - 1;
//        if (A != NULL && DofTypeOrder(A, e) >= 0)
//	    order += DofTypeOrder(A, e);
//	if (order < 0)
//	    order = 0;
//    }
//    quad = phgQuadGetQuad3D(order);
//
//    d = 0.;
//    g1 = phgQuadGetDofValues(e, u, quad);
//    g2 = phgQuadGetBasisGradient(e, v, m, quad);
//    w = quad->weights;
//
//    if (A == NULL) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    for (j = 0; j < nvalues; j++) {
//		d0 += *(g1++) * *(g2++);
//	    }
//	    d += d0 * (*(w++));
//	}
//	return d * phgGeomGetVolume(u->g, e);
//    }
//
//    An = DofDim(A);
//    coef = phgQuadGetDofValues(e, A, quad);
//    if (1 == An) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    for (j = 0; j < nvalues; j++) {
//		d0 += *(g1++) * *(g2++);
//	    }
//	    d += d0 * *(w++) * *(coef++);
//	}
//    }
//    else if (An == nvalues) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    for (j = 0; j < nvalues; j++) {
//		d0 += *(g1++) * *(g2++) * *(coef++);
//	    }
//	    d += d0 * *(w++);
//	}
//    }
//    else if (An == nvalues * nvalues) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    g2_tmp = g2;
//	    for (j = 0; j < nvalues; j++) {
//		g2 = g2_tmp;
//		for (k = 0; k < nvalues; k++)
//		    d0 += *g1 * *(g2++) * *(coef++);
//		g1++;
//	    }
//	    d += d0 * *(w++);
//	}
//
//    }
//    else {
//	phgError(1, "%s:%d: dimensions mismatch: coefficent A  %s (%d)",
//		 __FILE__, __LINE__, DofTypeName(A), DofTypeDim(A));
//    }
//
//    return d * phgGeomGetVolume(u->g, e);
//}
//
//FLOAT *
//phgQuadDofDotCurlBas_(SIMPLEX *e, DOF *u, DOF *v, int m, int order, FLOAT *res)
//{
//    int i,  nvalues = DofDim(u);
//    const FLOAT *g1, *g2, *w;
//    FLOAT d;
//    QUAD *quad;
//
//    assert(!SpecialDofType(v->type));
//
//    if (order < 0) {
//	order = BasisOrder(v, e, m) - 1;
//	if (DofTypeOrder(u, e) >= 0)
//	    order += DofTypeOrder(u, e);
//	if (order < 0)
//	    order = 0;
//    }
//    quad = phgQuadGetQuad3D(order);
//
//    g1 = phgQuadGetDofValues(e, u, quad);
//    g2 = phgQuadGetBasisGradient(e, v, m, quad);
//    w = quad->weights;
//
//    if (nvalues == Dim && v->dim == Dim && DofTypeDim(v) == 1) {
//        res[0] = res[1] = res[2] = 0.;
//	for (i = 0; i < quad->npoints; i++) {
//	    res[0] += (g1[1] * g2[2] - g1[2] * g2[1]) * (*w);
//	    res[1] += (g1[2] * g2[0] - g1[0] * g2[2]) * (*w);
//	    res[2] += (g1[0] * g2[1] - g1[1] * g2[0]) * (*w);
//	    w++;
//            g2 += Dim;
//	}
//	d = phgGeomGetVolume(u->g, e);
//        res[0] *= d;
//        res[1] *= d;
//        res[2] *= d;
//	return res;
//    } else {
//	phgError(1, "%s:%d: unimplement  ", __FILE__, __LINE__);
//        return NULL;
//    }
//}
//
//FLOAT
//phgQuadDofACurlBas(SIMPLEX *e, DOF *u, DOF *A, DOF *v, int m, int order)
//	/*
//	 * computes integration of
//	 *        DOF u
//	 *        \cdot
//	 *        A coefficient
//	 *        \cdot
//	 *        (Curl of 'm'-th basis function of 'v')
//	 *      on element 'e' using quadrature rule 'quad'.
//	 */
//{
//    int i, j, k, nvalues = DofDim(u), An;
//    const FLOAT *g1, *g2, *g2_tmp, *coef, *w;
//    FLOAT d, d0;
//    QUAD *quad;
//
//    assert(!SpecialDofType(v->type));
//    assert(nvalues == DofTypeDim(v));
//
//    if (order < 0) {
//	order = ((j = DofTypeOrder(u, e)) >= 0 ? j : BasisOrder(v, e, m));
//	order += BasisOrder(v, e, m) - 1;
//	if (A != NULL && DofTypeOrder(A, e) >= 0)
//	    order += DofTypeOrder(A, e);
//	if (order < 0)
//	    order = 0;
//    }
//    quad = phgQuadGetQuad3D(order);
//
//    d = 0.;
//    g1 = phgQuadGetDofValues(e, u, quad);
//    g2 = phgQuadGetBasisCurl(e, v, m, quad);
//    w = quad->weights;
//
//    if (A == NULL) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    for (j = 0; j < nvalues; j++) {
//		d0 += *(g1++) * *(g2++);
//	    }
//	    d += d0 * *(w++);
//	}
//	return d * phgGeomGetVolume(u->g, e);
//    }
//
//    An = DofDim(A);
//    coef = phgQuadGetDofValues(e, A, quad);
//    if (1 == An) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    for (j = 0; j < nvalues; j++) {
//		d0 += *(g1++) * *(g2++);
//	    }
//	    d += d0 * *(w++) * *(coef++);
//	}
//    }
//    else if (An == nvalues) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    for (j = 0; j < nvalues; j++) {
//		d0 += *(g1++) * *(g2++) * *(coef++);
//	    }
//	    d += d0 * *(w++);
//	}
//    }
//    else if (An == nvalues * nvalues) {
//	for (i = 0; i < quad->npoints; i++) {
//	    d0 = 0.;
//	    g2_tmp = g2;
//	    for (j = 0; j < nvalues; j++) {
//		g2 = g2_tmp;
//		for (k = 0; k < nvalues; k++)
//		    d0 += *g1 * *(g2++) * *(coef++);
//		g1++;
//	    }
//	    d += d0 * *(w++);
//	}
//    }
//    else {
//	phgError(1, "%s:%d: dimensions mismatch: coefficent A  %s (%d)",
//		 __FILE__, __LINE__, DofTypeName(A), DofTypeDim(A));
//    }
//
//    return d * phgGeomGetVolume(u->g, e);
//}
//
//FLOAT
//phgQuadGradBasDotBas(SIMPLEX *e, DOF *s, int m, DOF *v, int n, int order)
//	/*
//	   S is the voltage soure
//	   We choose it as the base function of P1 at vertex m,
//	   this function do
//	   int
//	   grad S * v
//	 */
//{
//    int i, j, nvalues = DofTypeDim(v);
//    const FLOAT *g1, *g2, *w, *lambda;
//    FLOAT d, d0;
//    QUAD *quad;
//
//    assert(!SpecialDofType(s->type) && !SpecialDofType(v->type));
//
//    if (nvalues != Dim * DofTypeDim(s))
//	phgError(1, "%s:%d, dimensions mismatch: grad(%s) <==> (%s)\n",
//		 __FILE__, __LINE__, s->name, v->name);
//
//    if (order < 0)
//	order = BasisOrder(s, e, m) - 1 + BasisOrder(v, e, n);
//    if (order < 0)
//	order = 0;
//    quad = phgQuadGetQuad3D(order);
//
//    g1 = phgQuadGetBasisGradient(e, s, m, quad);
//    g2 = phgQuadGetBasisValues(e, v, n, quad);
//    d = 0.;
//    lambda = quad->points;
//    w = quad->weights;
//    for (i = 0; i < quad->npoints; i++) {
//	d0 = 0.;
//	for (j = 0; j < nvalues; j++) {
//	    d0 += *(g1++) * (*(g2++));
//	}
//	d += d0 * (*(w++));
//	lambda += Dim + 1;
//    }
//    return d * phgGeomGetVolume(s->g, e);
//}
