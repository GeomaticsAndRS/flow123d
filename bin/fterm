#!/bin/bash
# This script can download flow123d images (adding user/group, adding keys, setting up git is made on thy fly)
# usage ./fterm [options] [dbg|rel] [action] [arguments]
#   options:
#     -v|--verbose    turn on debug mode
#     --set-x         turn on debug mode (set -x)
#
#   actions:
#     remove-old     - will prompt to remove old docker images and containers
#                      (those with no name)
#
#     update         - will update all flow123d images (will download new images
#                      from the hub.docker.com/u/flow123d if necessary)
#
#     run            - (default action) will start a docker image
#                      directory specified in config/docker.cfg file
#                      currently directory '$work' will be mounted
#
#   arguments: additional arguments passed to binary (if action is flow123d or run or runtest)
#
#    run            - (default action) will start a docker image
#                     directory specified in config/docker.cfg file
#                     currently directory '$work' will be mounted
#
#    flow123d       - will run flow123d binary and pass all given arguments
#                     specified after this value
#
#    runtest        - will run runtest binary and pass all given arguments
#                     specified after this value
#
#    make           - will run make and pass all given arguments
#                     specified after this value, DO NOT SET flag -j manually
#                     use FLOW123D_NUMCPUS for that

# The script can be configure with system variables:
#    FLOW123D_WORK      - the folder, which will be mounted
#    FLOW123D_NUMCPUS   - number of cpus, which will be used when called with pmake


# function will try to find proper dir to be mounted
# it will return $FLOW123D_WORK is set
# otherwise will return dir in $HOME, in which is flow123d located (can be even more nested)
# if the flow is not in a $HOME dir, will return parent directory
#    of the flow123d repo root direcotry (the one containing build-master etc)


# bin/fterm -- -di --name contrelease -euid=$(id -u) -v /opt/flow123d:/opt/flow123d

# get CWD as realtive path to current directory, which enables to build image on Windows
OLD_PWD="$(pwd)"
ABS_ROOT="$( cd "$( dirname "${BASH_SOURCE[0]}" )"/.. && pwd )"
ABS_BIN="$ABS_ROOT/bin"
ROOT=$(realpath --relative-to=$(pwd) $ABS_ROOT)
REL_BIN=$(realpath --relative-to=$(pwd) $ROOT/bin)

# define paths
BIN=$ROOT/bin
CFG=$ROOT/config
TMP=$ROOT/config/docker/.tmp
DKR=$ROOT/config/docker


# default version of the image used when **running** docker image
image_version=dbg

# default tag of the image when **running** images
# can be changed in the following manner:
#     ./fterm @2.2.0 build
#     ./fterm @3.0.0 update
#     ./fterm @latest
image_tag=latest

# if docker_version file exists, we change docker_version
if [[ -f "$CFG/docker/image_tag" ]]; then
  image_tag=$(cat $CFG/docker/image_tag)
fi


# prints usage
function usage() {
  cat << EOF
usage:
  $bold./fterm [options] [dbg|rel] [action] [arguments]$reset
  
  $bold Note:$reset The images are automatically downloaded from docker hub
  $bold Note:$reset To turn off terminal colors, set system variable nocolor=1
           $> nocolor=1 bin/fterm ...
         (color output is disabled by default in a non tty environment)
  
     To use different docker image libraries, use @<tag> syntax, such as:
      $bblue
        $REL_BIN/fterm @2.2.0 build
        $REL_BIN/fterm @3.0.0 update
        $REL_BIN/fterm @latest
      $reset
     You can also use file 'config/docker/image_tag' where you can change
     default <tag> value. Currently, the <tag> value is set to '$image_tag'.

  ${bold}options:${reset}
    ${bold}-v|--verbose ${reset}
      turn on debug mode
    ${bold}--set-x ${reset}
      turn on debug mode (set -x)

  ${bold}actions:${reset}
    ${bold} @<tag> ${reset}
      where <tag> value changes the tag value of the docker image
      which is used for running
                     
    ${bold}--${reset}
      will execute docker run and predetermined image and will
      pass remaining arguments to the [options] section 
      of the docker run command
      docker run [options] <predefined-image>
                     
    ${bold}--detach <name> [<opts> ...]${reset}
      will execute docker as a deamon in the background.
      Value <name> refers to a name of the container which will
      be assigned to a new container. <opts> are passed to the 
      docker run. e.g.:
      docker run <opts> ... flow123d/flow-libs-dev-dbg:2.2.0 
      
      ** This operation will delete any container which has **
              ** the same name as the name provided **
      
    ${bold}remove-old ${reset}
      will prompt to remove old docker images and containers
      (those with no name)

    ${bold}update${reset}
      will update all flow123d images (will download new images

    ${bold}run${reset}
      (default action) will start a docker image
      directory specified in config/docker.cfg file
      currently directory '$work' will be mounted

    ${bold}flow123d${reset}
      will run flow123d binary and pass all given arguments
      specified after this value

    ${bold}runtest${reset}
      will run runtest binary and pass all given arguments
      specified after this value

    ${bold}make${reset}
      will run make and pass all given arguments
      specified after this value, DO NOT SET flag -j manually
      use FLOW123D_NUMCPUS for that

  arguments: additional arguments passed to binary
             (if action is flow123d or run or runtest)

  To compile flow under docker, you can do the following:
    $bblue$REL_BIN/fterm make -C $ROOT all$reset

  To run flow under docker, you can do the following:
    $bblue$REL_BIN/fterm flow123d --help$reset

  To run tests under docker, you can do the following:
    $bblue$REL_BIN/fterm runtest $ROOT/tests/10_darcy$reset
  
EOF
}

function dbg() {
  if [[ $verbose -eq 1 ]]; then
    echo -e "$bgreen[DBG]$reset $@"
  fi
}
function dbgc() {
  if [[ $verbose -eq 1 ]]; then
    echo -e "$bblue[RUN]$reset $@"
  fi
}

function get_mount_dir() {
  if [[ -n $FLOW123D_WORK ]]; then
    echo $FLOW123D_WORK;
  else
    # try to find the first dir in $HOME, in which
    # flow123d is located
    local workdir=$1
    local workdir_tmp=
    for (( i = 0; i < 10; i++ )); do
      workdir_tmp=$(dirname $workdir)
      if [[ "$workdir_tmp" == "$HOME" ]]; then
        # we found what we were looking for
        echo $workdir
        return
      fi
      workdir=$workdir_tmp
    done
    # the folder is too deep or not in HOME
    # we return entire $HOME
    echo $(dirname $1)
  fi
}


# Will check whether given image exists and return 0 if it does
function image_exist() {
  did=$(docker images $1 -q)
  if [[ -z $did ]]; then
    return 1
  else
    return 0
  fi
}

# Will configure single file and makes it executabÅ¯e
function configure_file() {
  sed -e "s/@gid@/$gid/g" \
      -e "s/@uid@/$uid/g" \
      -e "s/@uname@/$uname/g" \
      -e "s/@flow_version@/$flow_version/g" \
      -e "s/@docker_image@/$docker_image/g" \
      -e "s/@image_version@/$image_version/g" \
      -e "s/@git_email@/$git_email/g" \
      -e "s/@git_uname@/$git_uname/g" \
      -e "s/@light_theme@/$light_theme/g" \
      "$1" > "$2"
  chmod +x $2
}




# Will pull all the images to newest
function update_images() {
  for image in $flow123d_images
  do
    docker pull flow123d/$image:$image_tag
  done
}


# Detects exited containers  and prompt user to delete them
# Detects untagged images and prompt user to delete them
function remove_old() {
  # ------------------------------------------------------------------------------
  EXITED=$(docker ps -q -f status=exited)
  if [[ -n $EXITED ]]; then
      echo "--------------------------------------------"
      echo "Note: You have exited containers present. Exited containers are usually"
      echo "      left overs which can be safely removed."
      echo "Containers are: "
      docker images | grep "^<none>"

      if [[ $YES_TO_ALL -eq 1 ]]; then
          docker rm -f $EXITED
      else
          read -p "Would you like to remove them [y/n]?" -r
          echo
          if [[ $REPLY =~ ^[Yy]$ ]]
          then
              docker rm -f $EXITED
          fi
      fi
      echo "--------------------------------------------"
  fi

  # ------------------------------------------------------------------------------
  UNNAMED=$(docker images | grep "^<none>" | awk "{print \$3}")
  if [[ -n $UNNAMED ]]; then
      echo "--------------------------------------------"
      echo "Note: You have untagged images present, this probably occured when images"
      echo "      were reinstalled. Even though these images can still be used it is "
      echo "      recommended to simply delete them."
      echo "Images are: "
      docker images | grep "^<none>"

      if [[ $YES_TO_ALL -eq 1 ]]; then
          docker rmi -f $UNNAMED
      else
          read -p "Would you like to remove them[y/n] ?" -r
          echo
          if [[ $REPLY =~ ^[Yy]$ ]]
          then
              docker rmi -f $UNNAMED
          fi
      fi
      echo "--------------------------------------------"
  fi
}

# check if stdout is a terminal...
if [[ -z "$nocolor" ]]; then
  if test -t 1; then
      # see if it supports colors...
      ncolors=$(tput colors)
      if test -n "$ncolors" && test $ncolors -ge 8; then
          bold="$(tput bold)"
          reset="$(tput sgr0)"
          red="$(tput setaf 1)"
          green="$(tput setaf 2)"
          yellow="$(tput setaf 3)"
          blue="$(tput setaf 4)"
          bblue="$bold$blue"
          bgreen="$bold$green"
          byellow="$bold$yellow"
          bred="$bold$red"
      fi
  fi
fi


# grab user's id
gid=$(id -g)
uid=$(id -u)
uname=flow # not using $(whoami) so there are no collisions with $HOME

# source config, that way we know what to mount, etc.
if [[ -f "$CFG/docker.cfg" ]]; then
  source $CFG/docker.cfg
fi

# default settings
verbose=1
action=run
work=$(get_mount_dir $ABS_ROOT)
numcpus=${FLOW123D_NUMCPUS:-1}
contname=""

while [[ $# -gt 0 ]]
  do
  key="$1"
  case $key in
    --set-x)
      set -x
      shift
    ;;
    -v|--verbose)
      verbose=1
      shift
    ;;
    -V|--no-verbose)
      verbose=0
      shift
    ;;
    --)
      shift
      action=raw
      rest="$@"
      break
    ;;
    --detach)
      contname="$2"
      action=detach
      shift; shift;
      rest="$@"
      break
    ;;
    config|remove-old|flow123d|run|runtest|make|update)
      action=$1
      shift
      break
    ;;
    dbg|rel)
      image_version=$1
      shift
    ;;
    @*)
      image_tag=${1#@}  # cut at (@) from the value
      shift
    ;;
    build@*|update@*)
      echo "Please use new syntax to specify docker image version"
      echo "instead of: "
      echo "./fterm build@2.2.0"
      echo "use"
      echo "./fterm @2.2.0 build"
      exit 1
    ;;
    -h|--help|help)
      echo "Help for the fterm:"
      usage
      exit 1
    ;;
    -i|--images)
      shift
      flow123d_images=$1
      shift
    ;;
    *)
      echo -e "${bred}ERROR:$reset ${red} Invalid argument '$1'!$reset"
      usage
      echo -e "${bred}ERROR:$reset ${red} Invalid argument '$1'!$reset"
      exit 1
    ;;
  esac
done



# determine image names
base_image=flow123d/flow-libs-dev-$image_version:$image_tag
flow123d_images="flow-libs-dev-dbg flow-libs-dev-rel"


dbg "base_image     = $base_image"
dbg "image_tag      = $image_tag"
dbg "image_version  = $image_version"
dbg "action         = $action"
dbg "mount dir      = $work"
dbg "user           = $uname($uid:$gid)"
dbg "container name = $contname"

# env variables which will be passed as well
envarg="-euid=$uid -egid=$gid -ewho=$uname -ehome=/mnt/$HOME -v $HOME:/mnt/$HOME"

# perform action based on variable action
case $action in
  raw)
    dbgc docker run $rest $base_image
    docker run $rest $base_image
  ;;
  detach)
    dbgc "docker rm -f $contname > /dev/null 2>&1"
    docker rm -f $contname > /dev/null 2>&1
    dbgc docker run -di $envarg $rest --name $contname -u $uid:$gid --entrypoint="" $base_image /bin/bash
    docker run -di $envarg $rest --name $contname -u $uid:$gid --entrypoint="" $base_image /bin/bash
    dbgc docker exec -u root $contname /usr/local/bin/entrypoint.sh id
    docker exec -u root $contname /usr/local/bin/entrypoint.sh id
  ;;
  flow123d)
    dbgc docker run --rm -it $envarg -w "$OLD_PWD" -v "$work":"$work" $base_image bash -lc "$ROOT/bin/flow123d $*"
    docker run --rm -it $envarg -w "$OLD_PWD" -v "$work":"$work" $base_image bash -lc "$ROOT/bin/flow123d $*"
  ;;
  runtest)
    dbgc docker run --rm -it $envarg -w "$OLD_PWD" -v "$work":"$work" $base_image bash -lc "$ROOT/bin/runtest $*"
    docker run --rm -it $envarg -w "$OLD_PWD" -v "$work":"$work" $base_image bash -lc "$ROOT/bin/runtest $*"
  ;;
  run)
    if [[ "$#" -eq 0 ]]; then
      dbgc "docker run --rm -it
          -w \"$OLD_PWD\"
          $envarg
          -v \"$work\":\"$work\"
          -e TESTS_DIR=\"$ABS_ROOT/tests\"
          $base_image
          bash -l
          \"export PATH=\$PATH:$ABS_BIN; bash -l\""
      docker run --rm -it \
          $envarg \
          -w "$OLD_PWD" \
          -v "$work":"$work" \
          -e TESTS_DIR="$ABS_ROOT/tests" \
          $base_image \
          bash -lc \
          "export PATH=\$PATH:$ABS_BIN; bash -l"
    else
      dbgc docker run --rm -it $envarg -w "$OLD_PWD" -v "$work":"$work" $base_image bash -lc "$*"
      docker run --rm -it $envarg -w "$OLD_PWD" -v "$work":"$work" $base_image bash -lc "$*"
    fi
  ;;
  make)
    dbgc docker run --rm -it $envarg -w "$OLD_PWD" -v "$work":"$work" $base_image bash -lc "/usr/bin/make -j $numcpus $*"
    docker run --rm -it $envarg -w "$OLD_PWD" -v "$work":"$work" $base_image bash -lc "/usr/bin/make -j $numcpus $*"
  ;;
  update)
    update_images
  ;;
  remove-old)
    remove_old
  ;;
esac

exit $?
