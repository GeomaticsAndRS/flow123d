#!/bin/bash
# This script can personalize flow123d images (adding user/group, adding keys, setting up git)
# usage ./fterm [options] [dbg|rel] [action] [arguments]
#   options:
#     -v|--verbose    turn on debug mode
#     --set-x         turn on debug mode (set -x)
#
#   actions:
#     clean          - will remove all personalized images, the other images
#                      will be left untouched
#
#     remove-old     - will prompt to remove old docker images and containers
#                      (those with no name)
#
#     update         - will update all flow123d images (will download new images
#                      from the hub.docker.com/u/flow123d if necessary)
#
#     build          - will create customized images (ending with user)
#
#     run            - (default action) will start a personalized image
#                      directory specified in config/docker.cfg file
#                      currently directory '$work' will be mounted
#
#   arguments: additional arguments passed to binary (if action is flow123d or run or runtest)
#
#    run            - (default action) will start a personalized image
#                     directory specified in config/docker.cfg file
#                     currently directory '$work' will be mounted
#
#    flow123d       - will run flow123d binary and pass all given arguments
#                     specified after this value
#
#    runtest        - will run runtest binary and pass all given arguments
#                     specified after this value
#
#    make           - will run make and pass all given arguments
#                     specified after this value, DO NOT SET flag -j manually
#                     use FLOW123D_NUMCPUS for that

# The script can be configure with system variables:
#    FLOW123D_WORK      - the folder, which will be mounted
#    FLOW123D_NUMCPUS   - number of cpus, which will be used when called with pmake


# function will try to find proper dir to be mounted
# it will return $FLOW123D_WORK is set
# otherwise will return dir in $HOME, in which is flow123d located (can be even more nested)
# if the flow is not in a $HOME dir, will return parent directory
#    of the flow123d repo root direcotry (the one containing build-master etc)

# get CWD as realtive path to current directory, which enables to build image on Windows
OLD_PWD="$(pwd)"
ABS_ROOT="$( cd "$( dirname "${BASH_SOURCE[0]}" )"/.. && pwd )"
ABS_BIN="$ABS_ROOT/bin"
ROOT=$(realpath --relative-to=$(pwd) $ABS_ROOT)
REL_BIN=$(realpath --relative-to=$(pwd) $ROOT/bin)

# define paths
BIN=$ROOT/bin
CFG=$ROOT/config
TMP=$ROOT/config/docker/.tmp
DKR=$ROOT/config/docker


# default version of the image used when **running** personalized image
image_version=dbg

# default tag of the image when **building** and **running** images
# can be changed in the following manner:
#     ./fterm @2.2.0 build
#     ./fterm @3.0.0 update
#     ./fterm @latest
image_tag=latest

# if docker_version file exists, we change docker_version
if [[ -f "$CFG/docker/image_tag" ]]; then
  image_tag=$(cat $CFG/docker/image_tag)
fi


# prints usage
function usage() {
  cat << EOF
usage:
  ./fterm [options] [dbg|rel] [action] [arguments]
  
  **Note** No need to call build, images are automatically downloaded and
           even personalized on the fly
           
           To use different docker image libraries, use @<tag> syntax, such as:
              $REL_BIN/fterm @2.2.0 build
              $REL_BIN/fterm @3.0.0 update
              $REL_BIN/fterm @latest
           
           You can also use file 'config/docker/image_tag' where you can change
           default <tag> value. Currently, the <tag> value is set to '$image_tag'.

  options:
    -v|--verbose    - turn on debug mode
    --set-x         - turn on debug mode (set -x)

  actions:
    @<tag>          - where <tag> value changes the tag value of the docker image which is used for
                     personalization and for running
                     
    --             - will execute docker run and predetermined image and will
                     pass remaining arguments to the [options] section 
                     of the docker run command
                     docker run [options] <predefined-image>
                     
    clean          - will remove all personalized images, the other images
                     will be left untouched

    remove-old     - will prompt to remove old docker images and containers
                     (those with no name)

    build          - will create customized images (ending with user-<tag>)

    update         - will update all flow123d images (will download new images

    run            - (default action) will start a personalized image
                     directory specified in config/docker.cfg file
                     currently directory '$work' will be mounted

    flow123d       - will run flow123d binary and pass all given arguments
                     specified after this value

    runtest        - will run runtest binary and pass all given arguments
                     specified after this value

    make           - will run make and pass all given arguments
                     specified after this value, DO NOT SET flag -j manually
                     use FLOW123D_NUMCPUS for that

  arguments: additional arguments passed to binary
             (if action is flow123d or run or runtest)

  To compile flow under docker, you can do the following:
    $REL_BIN/fterm make -C $ROOT all

  To run flow under docker, you can do the following:
    $REL_BIN/fterm flow123d --help

  To run tests under docker, you can do the following:
    $REL_BIN/fterm runtest $ROOT/tests/10_darcy
EOF
}

function dbg() {
  if [[ $verbose -eq 1 ]]; then
    echo -e "[DBG] $@"
  fi
}

function get_mount_dir() {
  if [[ -n $FLOW123D_WORK ]]; then
    echo $FLOW123D_WORK;
  else
    # try to find the first dir in $HOME, in which
    # flow123d is located
    local workdir=$1
    local workdir_tmp=
    for (( i = 0; i < 10; i++ )); do
      workdir_tmp=$(dirname $workdir)
      if [[ "$workdir_tmp" == "$HOME" ]]; then
        # we found what we were looking for
        echo $workdir
        return
      fi
      workdir=$workdir_tmp
    done
    # the folder is too deep or not in HOME
    # we return entire $HOME
    echo $(dirname $1)
  fi
}


# Will check whether given image exists and return 0 if it does
function image_exist() {
  did=$(docker images $1 -q)
  if [[ -z $did ]]; then
    return 1
  else
    return 0
  fi
}

# Will configure single file and makes it executabÅ¯e
function configure_file() {
  sed -e "s/@gid@/$gid/g" \
      -e "s/@uid@/$uid/g" \
      -e "s/@uname@/$uname/g" \
      -e "s/@image_tag@/$image_tag/g" \
      -e "s/@docker_image@/$docker_image/g" \
      -e "s/@image_version@/$image_version/g" \
      -e "s/@git_email@/$git_email/g" \
      -e "s/@git_uname@/$git_uname/g" \
      -e "s/@light_theme@/$light_theme/g" \
      "$1" > "$2"
  chmod +x $2
}

# Will configure all the files for the build process
function configure_files {
  configure_file "$DKR/customize/setup.sh"    "$TMP/setup.sh"
  configure_file "$DKR/customize/Dockerfile"  "$TMP/Dockerfile"
}

# Will alter single image
function alter_image() {
  local tmp_base_image=$1  # something like 'flow123d/flow-libs-dev-dbg:latest'
  local tmp_user_image=$2  # something like 'flow123d/flow-libs-dev-dbg:user-latest'

  # create dummy config files
  mkdir -p  "$TMP/.ssh/"
  touch     "$TMP/.gitconfig"
  touch     "$TMP/.ssh/known_hosts"

  # set docker_image globally, this way, configuring user image
  # will use docker_image value as a parent
  docker_image=${tmp_base_image#flow123d/}
  # create Dockerfile and sh file for this image
  configure_files

  cp -r "$HOME/.ssh/"       "$TMP/"
  cp -r "$HOME/.gitconfig"  "$TMP/"

  docker rm -f       $tmp_user_image # remove previous image
  docker build --tag $tmp_user_image --no-cache=true "$TMP"

  # remove tmp dir
  rm -rf "$TMP"
}

# Will build custom images
function make_work_images() {
  echo '----------------------------------------------------'
  echo "Creating developer images for user $uname ($uid:$gid)"

  for image in $flow123d_images
  do
      if image_exist "flow123d/$image:$image_tag"; then
        echo '----------------------------------------------------'
        echo "altering image $image:$image_tag"
        alter_image "$image" "$image_tag"
      fi
  done
}

# Will remove all custom images
function remove_custom_images() {
  for image in $flow123d_images
  do
    docker rmi -f flow123d/$image:user-$image_tag
  done
}

# Will pull all the images to newest
function update_images() {
  for image in $flow123d_images
  do
    docker pull flow123d/$image:$image_tag
  done
  # remove custom images after an update
  remove_custom_images
}


# Detects exited containers  and prompt user to delete them
# Detects untagged images and prompt user to delete them
function remove_old() {
  # ------------------------------------------------------------------------------
  EXITED=$(docker ps -q -f status=exited)
  if [[ -n $EXITED ]]; then
      echo "--------------------------------------------"
      echo "Note: You have exited containers present. Exited containers are usually"
      echo "      left overs which can be safely removed."
      echo "Containers are: "
      docker images | grep "^<none>"

      if [[ $YES_TO_ALL -eq 1 ]]; then
          docker rm -f $EXITED
      else
          read -p "Would you like to remove them? " -n 1 -r
          echo
          if [[ $REPLY =~ ^[Yy]$ ]]
          then
              docker rm -f $EXITED
          fi
      fi
      echo "--------------------------------------------"
  fi

  # ------------------------------------------------------------------------------
  UNNAMED=$(docker images | grep "^<none>" | awk "{print \$3}")
  if [[ -n $UNNAMED ]]; then
      echo "--------------------------------------------"
      echo "Note: You have untagged images present, this probably occured when images"
      echo "      were reinstalled. Even though these images can still be used it is "
      echo "      recommended to simply delete them."
      echo "Images are: "
      docker images | grep "^<none>"

      if [[ $YES_TO_ALL -eq 1 ]]; then
          docker rmi -f $UNNAMED
      else
          read -p "Would you like to remove them? " -n 1 -r
          echo
          if [[ $REPLY =~ ^[Yy]$ ]]
          then
              docker rmi -f $UNNAMED
          fi
      fi
      echo "--------------------------------------------"
  fi
}

function build_if_not_exists() {
  local tmp_base_image=${1:-$base_image}
  local tmp_user_image=${2:-$user_image}

  if image_exist $tmp_user_image; then
    dbg "user image '$tmp_user_image' already exists"
  else
    echo "user image '$tmp_user_image' will now be created"
    alter_image $tmp_base_image $tmp_user_image
  fi
}


# grab user's id
gid=$(id -g)
uid=$(id -u)
uname=$(whoami)
light_theme=0


# source config, that way we know what to mount, etc.
if [[ -f "$CFG/docker.cfg" ]]; then
  source $CFG/docker.cfg
fi

# default settings
verbose=0
action=run
work=$(get_mount_dir $ABS_ROOT)
numcpus=${FLOW123D_NUMCPUS:-1}


while [[ $# -gt 0 ]]
  do
  key="$1"
  case $key in
    --set-x)
      set -x
      shift
    ;;
    -v|--verbose)
      verbose=1
      shift
    ;;
    --)
      shift
      action=raw
      rest="$@"
      break
    ;;
    config|clean|remove-old|flow123d|run|runtest|make|build|update)
      action=$1
      shift
      break
    ;;
    dbg|rel)
      image_version=$1
      shift
    ;;
    @*)
      image_tag=${1#@}  # cut at (@) from the value
      shift
    ;;
    build@*|update@*)
      echo "Please use new syntax to specify docker image version"
      echo "instead of: "
      echo "./fterm build@2.2.0"
      echo "user"
      echo "./fterm @2.2.0 build"
      exit 1
    ;;
    -h|--help|help)
      echo "Help for the fterm:"
      usage
      exit 1
    ;;
    *)
      echo "Invalid argument!"
      usage
      exit 1
    ;;
  esac
done


# determine image names
base_image=flow123d/flow-libs-dev-$image_version:$image_tag
user_image=flow123d/flow-libs-dev-$image_version:user-$image_tag
flow123d_images="flow-libs-dev-dbg flow-libs-dev-rel"


dbg "base_image     = $base_image"
dbg "user_image     = $user_image"
dbg "image_tag      = $image_tag"
dbg "image_version  = $image_version"
dbg "action         = $action"


# we build image if no personalid image exists
case $action in
  raw|flow123d|runtest|make|run)
    build_if_not_exists $base_image $user_image
  ;;
esac


# perform action based on variable action
case $action in
  raw)
    dbg docker run $rest $user_image
    docker run $rest $user_image
  ;;
  flow123d)
    dbg docker run --rm -it -w "$OLD_PWD" -v "$work":"$work" $user_image bash -lc "$ROOT/bin/flow123d $*"
    docker run --rm -it -w "$OLD_PWD" -v "$work":"$work" $user_image bash -lc "$ROOT/bin/flow123d $*"
  ;;
  runtest)
    dbg docker run --rm -it -w "$OLD_PWD" -v "$work":"$work" $user_image bash -lc "$ROOT/bin/runtest $*"
    docker run --rm -it -w "$OLD_PWD" -v "$work":"$work" $user_image bash -lc "$ROOT/bin/runtest $*"
  ;;
  run)
    if [[ "$#" -eq 0 ]]; then
      dbg "docker run --rm -it
          -w \"$OLD_PWD\"
          -v \"$work\":\"$work\"
          -e TESTS_DIR=\"$ABS_ROOT/tests\"
          $user_image
          bash -l
          \"export PATH=\$PATH:$ABS_BIN; bash -l\""
      docker run --rm -it \
          -w "$OLD_PWD" \
          -v "$work":"$work" \
          -e TESTS_DIR="$ABS_ROOT/tests" \
          $user_image \
          bash -lc \
          "export PATH=\$PATH:$ABS_BIN; bash -l"
    else
      dbg docker run --rm -it -w "$OLD_PWD" -v "$work":"$work" $user_image bash -lc "$*"
      docker run --rm -it -w "$OLD_PWD" -v "$work":"$work" $user_image bash -lc "$*"
    fi
  ;;
  make)
    dbg docker run --rm -it -w "$OLD_PWD" -v "$work":"$work" $user_image bash -lc "/usr/bin/make -j $numcpus $*"
    docker run --rm -it -w "$OLD_PWD" -v "$work":"$work" $user_image bash -lc "/usr/bin/make -j $numcpus $*"
  ;;
  build)
    make_work_images
  ;;
  update)
    update_images
  ;;
  clean)
    remove_custom_images
  ;;
  remove-old)
    remove_old
  ;;
esac
