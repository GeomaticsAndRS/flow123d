# CMAKE system TODO
#
# * make our own module FindPETSC  using native cmake support in PETSC version >3.2 
# * check external packages in FindPETSC, in particular Parmetis
# * better organisation of CMAKE files
#
# * use ExternalProject - feature of cmake >2.8, to automatically download and instal required libraries: boost, armadilo, petsc (with parmetis )
#   this way we can drop third_party directory; however for particular configuration of armadillo or petsc ( using particular libraries) one still need manual
#   installation of PETSc, so there should be posibility to indicate PETSC_DIR and PETSC_ARCH in makefile.in.cmake. But this file should be merly optional.
# 
# * use CTest to perform unit tests
# 
# * use CPack to  make Windows and Linux packages
#
# * possibly replace whole main makefile, this includes:
#       
#   - reproduce %.tst target in root dir in makefile generated by cmake
#   - build ngh and bcd ?? rather include them into flow123d
#   - clean and clean-all targets
#   - doxygen target    
#
# - use compiler flags from PETSc as defaults ( different setting can make problems with optimization)
#
# * how to organize flow123d libraries? I want:
#    1) each library should declare on which libraries it depends, but should not link against them (not contain them)
#       this setting should by automatically used in final linking
#    2) In particular third party libraries should not be part of any our library
#   - This requires carefull understanding of target_link_libraries commad, may be that this command DO NOT actualy
#     include library into library
#   - in that case how to produce flow123_lib EXPLICITELY containing all flow sub-libraries
#

# Include settings given by user first
set(CMAKE_INCLUDE_CURRENT_DIR ON)
include(${CMAKE_CURRENT_SOURCE_DIR}/makefile.in.cmake )


# Project name and language(s)
project(Flow123d CXX C)

# CMake version required for pre-build this project
cmake_minimum_required(VERSION 2.6.4)
if (${CMAKE_VERSION} VERSION_GREATER 2.8.4)
  cmake_policy(VERSION 2.8.4)
endif()

if (${CMAKE_CXX_COMPILER} MATCHES  "clang")
    # this is necessary due to some "bugs" in Armadillo
    add_definitions(-Wno-uninitialized)
endif()

# Set all module paths
set(CMAKE_MODULE_PATH "${CMAKE_ROOT}/Modules")
list(APPEND CMAKE_MODULE_PATH "${Flow123d_SOURCE_DIR}/CMake/Modules")

#in_source builds should buitd in ./build subdirectory
# this doesn;t work :-(
#if (${CMAKE_BINARY_DIR} EQUAL ${CMAKE_SOURCE_DIR}) 
#  set(CMAKE_BINARY_DIR ${CMAKE_SOURCE_DIR}/build)
#endif()

######################################################################### find libraries

# We are looking for PETSC, f succed this module set:
#  PETSC_FOUND        - system has PETSc
#  PETSC_INCLUDES     - the PETSc include directories
#  PETSC_LIBRARIES    - Link these to use PETSc
#  PETSC_COMPILER     - Compiler used by PETSc, helpful to find a compatible MPI
#  PETSC_DEFINITIONS  - Compiler switches for using PETSc
#  PETSC_MPIEXEC      - Executable for running MPI programs
#  PETSC_VERSION      - Version string (MAJOR.MINOR.SUBMINOR)
find_package(PETSc 3.2.0)
find_package(PARMETIS)

if (NOT PETSC_FOUND)
# === Variables ===
# This module will set the following variables per language in your project,
# where <lang> is one of C, CXX, or Fortran:
#   MPI_<lang>_FOUND           TRUE if FindMPI found MPI flags for <lang>
#   MPI_<lang>_COMPILER        MPI Compiler wrapper for <lang>
#   MPI_<lang>_COMPILE_FLAGS   Compilation flags for MPI programs
#   MPI_<lang>_INCLUDE_PATH    Include path(s) for MPI header
#   MPI_<lang>_LINK_FLAGS      Linking flags for MPI programs
#   MPI_<lang>_LIBRARIES       All libraries to link MPI programs against
# Additionally, FindMPI sets the following variables for running MPI
# programs from the command line:
#   MPIEXEC                    Executable for running MPI programs
#   MPIEXEC_NUMPROC_FLAG       Flag to pass to MPIEXEC before giving
#                              it the number of processors to run on
#   MPIEXEC_PREFLAGS           Flags to pass to MPIEXEC directly
#                              before the executable to run.
#   MPIEXEC_POSTFLAGS          Flags to pass to MPIEXEC after other flags

  find_package(MPI)
  
  if (NOT MPI_CXX_FOUND) 
    set(mpiuni_sources    system/mpiuni/mpi.c)
    set(MPIUNI_INCLUDES src/system/mpiuni)
    add_definitions(-DHAVE_MPI -DHAVE_MPIUNI)
    
    # overwrite NOTFOUND status
    set(MPI_CXX_LIBRARIES "")
    set(MPI_CXX_INCLUDE_PATH "")
  else()
    add_definitions(-DHAVE_MPI)
  endif()
  
else()
  add_definitions(-DHAVE_PETSC -DHAVE_MPI)
endif()


# find boost or use our own
#
find_package(Boost 1.42.0 )
if (NOT Boost_FOUND) 
  message(STATUS "Try to use our essential Boost subset.")
  unset(Boost_INCLUDE_DIR CACHE)        # overwrite cache    
  unset(Boost_LIBRARY_DIRS CACHE)
  unset(Boost_LIB_VERSION CACHE)
  unset(Boost_VERSION CACHE)  

  set(BOOST_ROOT ${CMAKE_SOURCE_DIR}/third_party/boost-1.42)
  find_package(Boost 1.42.0 EXACT REQUIRED)
  
  # hint same Boost to armadillo 
  set(Armadillo_Boost_Hint  -D BOOST_ROOT=${CMAKE_SOURCE_DIR}/third_party/boost-1.42)
endif()
message(STATUS "Boost_INCLUDE_DIR = ${Boost_INCLUDE_DIR}")


# find aramdillo or use our own
# FindAramdillo returs:
# Aramdillo_INCLUDE_DIRS
# Armadillo_LIBRARIES
find_package(Armadillo)
if (NOT Armadillo_FOUND)

  # THIS IS NOT CORRECT WAY TO BUILD Armadillo, IT MERLY WORKS. DO NOT FOLLOW THIS.
  # proper way should be: cmake, make, install Armadillo -> the last step should produce ArmadilloLibraryDepends.cmake
  # which can be included here to get correct includes and libs variables
  message(STATUS "Build our own Armadillo.")
  set(ARMADILLO_BUILD_DIR "${CMAKE_SOURCE_DIR}/third_party/armadillo-1.1.92/flow_build")
  file(MAKE_DIRECTORY "${ARMADILLO_BUILD_DIR}")
  execute_process(COMMAND ${CMAKE_COMMAND} -DCMAKE_PREFIX_PATH=${PETSC_DIR}/${PETSC_ARCH}  ${Armadillo_Boost_Hint} ..
                 WORKING_DIRECTORY "${ARMADILLO_BUILD_DIR}")
  execute_process(COMMAND make 
                 WORKING_DIRECTORY "${ARMADILLO_BUILD_DIR}")
  
  SET(Armadillo_INCLUDE_DIRS 
    ${CMAKE_SOURCE_DIR}/third_party/armadillo-1.1.92/flow_build/include
    ${CMAKE_SOURCE_DIR}/third_party/armadillo-1.1.92/include)  
  SET(Armadillo_LIBRARIES "${CMAKE_SOURCE_DIR}/third_party/armadillo-1.1.92/flow_build/libarmadillo.a" ${ARMA_LIBS})  
  
  message(STATUS "arma libs: ${ARMA_LIBS}")
endif()

message(STATUS "Arma inc: ${Armadillo_INCLUDE_DIRS}")



# check for subversion and prepare generating of file with revision info.
find_package(Subversion REQUIRED)

# include the output directory, where the svnversion.h file is generated
include_directories(${CMAKE_CURRENT_BINARY_DIR})


################################################################### set includes and libraries paths

include_directories(
    ${CMAKE_SOURCE_DIR}/src
    ${CMAKE_SOURCE_DIR}/third_party/metis-4.0/Lib
    ${CMAKE_SOURCE_DIR}/third_party/fparser-4.4.3
    ${CMAKE_SOURCE_DIR}/third_party/json_spirit
    ${PETSC_INCLUDES}
    ${Boost_INCLUDE_DIR}
    ${Armadillo_INCLUDE_DIRS}
    ${MPI_CXX_INCLUDE_PATH}
    ${MPIUNI_INCLUDES}  
)

##############
# set appropriate compiler flags for debug/release compilation modes

if(CC_FLAGS) 
  add_definitions(${CC_FLAGS})
  set(CMAKE_EXE_LINKER_FLAGS ${CC_FLAGS})
else()
  if(CMAKE_BUILD_TYPE STREQUAL "debug")
    # debug mode
    add_definitions("-g -O0")
    set(CMAKE_EXE_LINKER_FLAGS "-g")
    add_definitions(-DDEBUG)
  else()
    # Release mode
    add_definitions("-O3")
    add_definitions(-DNODEBUG)
  endif()
endif()
##############

############################################################33 process subdirectories

# add json_sprit sources
add_subdirectory( ${CMAKE_SOURCE_DIR}/third_party/json_spirit )

# add fparser sources
add_subdirectory(third_party/fparser-4.4.3)

# add various our sources
add_subdirectory(src)
add_subdirectory(doc)
add_subdirectory(test_units)

#################################################################### add targets


if( PETSC_FOUND )

  #### create rev_num.h - file with revision number
  # a custom target - is always built -> call cmake script to generate rev_num.h
  add_custom_target(rev_num_always 
    COMMAND ${CMAKE_COMMAND} -DSOURCE_DIR=${CMAKE_CURRENT_SOURCE_DIR}
                         -P ${CMAKE_CURRENT_SOURCE_DIR}/CMake/Modules/Flow123d_svn_rev_num.cmake)

  # rev_num.h is a generated file
  set_source_files_properties(${CMAKE_CURRENT_BINARY_DIR}/rev_num.h
    PROPERTIES GENERATED TRUE
    HEADER_FILE_ONLY TRUE)


  #### make a script which call correct mpiexec (taken from PETSC)
  # we can not use link, since mpiexec can be sript which reads its location from calling sequence
  if(EXISTS ${PETSC_MPIEXEC})
      set(MPIEXEC_PATH ${PETSC_MPIEXEC})
  else()
      if(COMMAND mpiexec)
        message(WARNING "Missing mpiexec in PETSc instalation. Using system wide mpiexec.")
        set(MPIEXEC_PATH mpiexec)
      else()
        message(WARNING "Missing any mpiexec.")
      endif()
  endif()
  configure_file(${CMAKE_SOURCE_DIR}/CMake/mpiexec_link_template ${CMAKE_BINARY_DIR}/mpiexec)
  


  ### add target for flow123d binary
  add_executable(flow123d src/main.cc)
  target_link_libraries(flow123d   flow123d_lib semchem)     # set libraries linked to main binary (order matter)
  add_dependencies(flow123d rev_num_always mpiexec_link)      # make mpiexec_link when flow123d executable is built

  # explicitly say that source file depends on rev_num_always in order to have actual revision number
  set_source_files_properties(src/main.cc OBJECT_DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/rev_num.h )
else()
  message(STATUS "PETSC not found. Omitting configuration of the target 'flow123d'.")
endif()


### add target for interpolation binary
add_executable(interpolation src/interpolation/interpolation_main.cc)
target_link_libraries(interpolation  system_lib new_mesh_lib ${Armadillo_LIBRARIES})
